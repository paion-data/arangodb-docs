<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AQL Documentation on ArangoDB Documentation</title><link>http://localhost/3.11/aql/</link><description>Recent content in AQL Documentation on ArangoDB Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://localhost/3.11/aql/index.xml" rel="self" type="application/rss+xml"/><item><title>How to execute AQL queries</title><link>http://localhost/3.11/aql/how-to-invoke-aql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/aql/how-to-invoke-aql/</guid><description>AQL queries can be invoked in the following ways:
Via the web interface Using the db object of the JavaScript API, for example, in arangosh or in a Foxx service Via the raw REST HTTP API There are always calls to the server&amp;rsquo;s HTTP API under the hood, but the web interface and the db object abstract away the low-level communication details and are thus easier to use.
The ArangoDB web interface has a specific section for QUERIES.</description></item><item><title>AQL Fundamentals</title><link>http://localhost/3.11/aql/fundamentals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/aql/fundamentals/</guid><description/></item><item><title>Operators</title><link>http://localhost/3.11/aql/operators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/aql/operators/</guid><description>Comparison operators Comparison (or relational) operators compare two operands. They can be used with any input data types, and return a boolean result value.
The following comparison operators are supported:
Operator Description == equality != inequality &amp;lt; less than &amp;lt;= less or equal &amp;gt; greater than &amp;gt;= greater or equal IN test if a value is contained in an array NOT IN test if a value is not contained in an array LIKE tests if a string value matches a pattern NOT LIKE tests if a string value does not match a pattern =~ tests if a string value matches a regular expression !</description></item><item><title>AQL Data Queries</title><link>http://localhost/3.11/aql/data-queries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/aql/data-queries/</guid><description>There are two fundamental types of AQL queries:
queries which access data (read documents) queries which modify data (create, update, replace, delete documents) Data Access Queries Retrieving data from the database with AQL does always include a RETURN operation. It can be used to return a static value, such as a string:
RETURN &amp;#34;Hello ArangoDB!&amp;#34; The query result is always an array of elements, even if a single element was returned and contains a single element in that case: [&amp;quot;Hello ArangoDB!</description></item><item><title>High-level AQL operations</title><link>http://localhost/3.11/aql/high-level-operations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/aql/high-level-operations/</guid><description/></item><item><title>AQL functions</title><link>http://localhost/3.11/aql/functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/aql/functions/</guid><description>Functions can be called at any query position where an expression is allowed. The general function call syntax is:
FUNCTIONNAME(arguments) FUNCTIONNAME is the name of the function to be called, and arguments is a comma-separated list of function arguments. If a function does not need any arguments, the argument list can be left empty. However, even if the argument list is empty, the parentheses around it are still mandatory to make function calls distinguishable from variable names.</description></item><item><title>Graphs in AQL</title><link>http://localhost/3.11/aql/graphs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/aql/graphs/</guid><description>There are multiple ways to work with graphs in ArangoDB, as well as different ways to query your graphs using AQL.
The two options in managing graphs are to either use
named graphs where ArangoDB manages the collections involved in one graph, or graph functions on a combination of document and edge collections. Named graphs can be defined through the graph-module or via the web interface. The definition contains the name of the graph, and the vertex and edge collections involved.</description></item><item><title>AQL Query Patterns and Examples</title><link>http://localhost/3.11/aql/examples-and-query-patterns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/aql/examples-and-query-patterns/</guid><description>These pages contain some common query patterns with examples. For better understandability the query results are also included directly below each query.
Normally, you would want to run queries on data stored in collections. This section will provide several examples for that.
Some of the following example queries are executed on a collection users with the data provided here below.
Things to consider when running queries on collections Note that all documents created in any collections will automatically get the following server-generated attributes:</description></item><item><title>Extending AQL with user-defined functions</title><link>http://localhost/3.11/aql/user-defined-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/aql/user-defined-functions/</guid><description>AQL comes with a built-in set of functions, but it is not a fully-featured programming language. To add missing functionality or to simplify queries, you may write your own user-defined functions (UDFs) in JavaScript and make them available in AQL.
Known Limitations UDFs can have serious effects on the performance of your queries and the resource usage in ArangoDB. Especially in cluster setups they should not be used against much data, because this data will need to be sent over the network back and forth between DB-Servers and Coordinators, potentially adding a lot of latency.</description></item><item><title>AQL Execution and Performance</title><link>http://localhost/3.11/aql/execution-and-performance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/aql/execution-and-performance/</guid><description/></item><item><title>Common Errors in AQL</title><link>http://localhost/3.11/aql/common-errors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/aql/common-errors/</guid><description>Trailing semicolons in query strings Many SQL databases allow sending multiple queries at once. In this case, multiple queries are separated using the semicolon character. Often it is also supported to execute a single query that has a semicolon at its end.
AQL does not support this, and it is a parse error to use a semicolon at the end of an AQL query string.
String concatenation In AQL, strings must be concatenated using the CONCAT() function.</description></item></channel></rss>