<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Working with Indexes on ArangoDB Documentation</title><link>http://localhost/3.11/index-and-search/indexing/working-with-indexes/</link><description>Recent content in Working with Indexes on ArangoDB Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://localhost/3.11/index-and-search/indexing/working-with-indexes/index.xml" rel="self" type="application/rss+xml"/><item><title>Persistent indexes</title><link>http://localhost/3.11/index-and-search/indexing/working-with-indexes/persistent-indexes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/index-and-search/indexing/working-with-indexes/persistent-indexes/</guid><description>It is possible to define a persistent index on one or more document attributes (or attribute paths). The index is then used in queries to locate documents with a specific index attribute value or to find documents whose index attribute value(s) are in a given range.
For example, you can create a persistent index on the attributes value1 and value2 with the following command:
collection.ensureIndex({ type: &amp;#34;persistent&amp;#34;, fields: [&amp;#34;value1&amp;#34;, &amp;#34;value2&amp;#34;] }); If you declare an index to be unique, then no two documents are allowed to have the same set of attribute values.</description></item><item><title>Inverted indexes</title><link>http://localhost/3.11/index-and-search/indexing/working-with-indexes/inverted-indexes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/index-and-search/indexing/working-with-indexes/inverted-indexes/</guid><description>Documents hold attributes, mapping attribute keys to values. Inverted indexes store mappings from values (of document attributes) to their locations in collections. You can create these indexes to accelerate queries like value lookups, range queries, accent- and case-insensitive search, wildcard and fuzzy search, nested search, as well as for sophisticated full-text search with the ability to search for words, phrases, and more.
You can use inverted indexes as follows:
Stand-alone in FILTER operations of AQL queries.</description></item><item><title>TTL Indexes</title><link>http://localhost/3.11/index-and-search/indexing/working-with-indexes/ttl-indexes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/index-and-search/indexing/working-with-indexes/ttl-indexes/</guid><description>Introduction to TTL (time-to-live) Indexes The TTL index type provided by ArangoDB can be used for removing expired documents from a collection.
The TTL index is set up by setting an expireAfter value and by selecting a single document attribute which contains a reference point in time. For each document, that reference point in time can then be specified as a numeric timestamp (Unix timestamp) or a date string in format YYYY-MM-DDTHH:MM:SS, optionally with milliseconds after a decimal point in the format YYYY-MM-DDTHH:MM:SS.</description></item><item><title>Fulltext indexes</title><link>http://localhost/3.11/index-and-search/indexing/working-with-indexes/fulltext-indexes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/index-and-search/indexing/working-with-indexes/fulltext-indexes/</guid><description>The fulltext index type is deprecated from version 3.10 onwards. It is recommended to use Inverted indexes or ArangoSearch for advanced full-text search capabilities. Introduction to Fulltext Indexes A fulltext index can be used to find words, or prefixes of words inside documents.
A fulltext index can be defined on one attribute only, and will include all words contained in documents that have a textual value in the index attribute.</description></item><item><title>Multi-dimensional indexes</title><link>http://localhost/3.11/index-and-search/indexing/working-with-indexes/multi-dimensional-indexes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/index-and-search/indexing/working-with-indexes/multi-dimensional-indexes/</guid><description>A multi-dimensional index maps multi-dimensional data in the form of multiple numeric attributes to one dimension while mostly preserving locality so that similar values in all of the dimensions remain close to each other in the mapping to a single dimension. Queries that filter by multiple value ranges at once can be better accelerated with such an index compared to a persistent index.
The multi-dimensional index type is called zkd.</description></item><item><title>Geo-Spatial Indexes</title><link>http://localhost/3.11/index-and-search/indexing/working-with-indexes/geo-spatial-indexes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/index-and-search/indexing/working-with-indexes/geo-spatial-indexes/</guid><description>The geo-spatial index type in ArangoDB is based on Google S2&amp;nbsp;. Indexing is supported for a subset of the GeoJSON geometry types as well as simple latitude/longitude pairs.
AQL&amp;rsquo;s geospatial functions and GeoJSON constructors are described in Geo functions.
You can also perform geospatial searches with ArangoSearch.
Using a Geo-Spatial Index The geospatial index supports distance, containment, and intersection queries for various geometric 2D shapes. You should mainly be using AQL queries to perform these types of operations.</description></item><item><title>Vertex-Centric Indexes</title><link>http://localhost/3.11/index-and-search/indexing/working-with-indexes/vertex-centric-indexes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/index-and-search/indexing/working-with-indexes/vertex-centric-indexes/</guid><description>All edge collections in ArangoDB have a special edge index that enables fast graph operations. If you have graphs that contain supernodes (vertices that have an exceptionally high amount of connected edges) and you apply filters in graph traversal queries, you can create so-called vertex-centric indexes that can perform better than the default edge indexes. You can use the persistent index type for this purpose.
Motivation The idea of a vertex-centric index is to index a combination of a vertex, the direction, and an arbitrary set of attributes on the edges.</description></item></channel></rss>