<!doctype html><html lang=en><head><link href=//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.no-icons.min.css rel=stylesheet><link href=//netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css rel=stylesheet><link href=/css/fontawesome-all.min.css rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/fontawesome-all.min.css rel=stylesheet></noscript><link href=/css/featherlight.min.css rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/featherlight.min.css rel=stylesheet></noscript><link href=/css/nucleus.css rel=stylesheet><link href=/css/fonts.css rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/fonts.css rel=stylesheet></noscript><link href=/css/theme.css rel=stylesheet><link href=/css/theme-relearn-light.css rel=stylesheet id=variant-style><link href=/css/print.css rel=stylesheet media=print><script src=/js/variant.js?1743774193></script>
<script>var root_url="/",baseUriFull,baseUri=root_url.replace(/\/$/,"");window.T_Copy_to_clipboard="",window.T_Copied_to_clipboard="",window.T_Copy_link_to_clipboard="",window.T_Link_copied_to_clipboard="",baseUriFull="http://localhost/",window.variants&&variants.init(["relearn-light"])</script><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.119.0"><meta itemprop=description property="description" content="You can use Pregel algorithms for graph exploration, path finding, analytics queries, and much more"><meta property="og:url" content="http://localhost/3.11/data-science/pregel/algorithms/"><meta property="og:title" content="Pregel Algorithms"><meta property="og:type" content="website"><meta property="og:description" content="You can use Pregel algorithms for graph exploration, path finding, analytics queries, and much more"><meta name=docsearch:version content="3.11"><title>Pregel Algorithms | ArangoDB Documentation</title><link href=/images/favicon.png rel=icon type=image/png><script src=/js/jquery.min.js></script>
<script src=/js/clipboard.min.js?1743774193 defer></script>
<script src=/js/featherlight.min.js?1743774193 defer></script>
<script>var versions=[{alias:"devel",deprecated:!1,name:"3.13",version:"3.13.0"},{alias:"stable",deprecated:!1,name:"3.12",version:"3.12.4"},{alias:"3.11",deprecated:!1,name:"3.11",version:"3.11.13"},{alias:"3.10",deprecated:!0,name:"3.10",version:"3.10.14"}]</script><script>var develVersion={alias:"devel",deprecated:!1,name:"3.13",version:"3.13.0"}</script><script>var stableVersion={alias:"stable",deprecated:!1,name:"3.12",version:"3.12.4"}</script><script src=/js/codeblocks.js?1743774193 defer></script>
<script src=/js/theme.js?1743774193 defer></script></head><body><noscript>You need to enable JavaScript to use the ArangoDB documentation.</noscript><div id=page-wrapper class=page_content_splash style=height:auto;opacity:0><section id=page-main><section class=page-container id=page-container><header id=header style="transition:.5s padding ease-out,.15s" class="zn_header_white header-splash-new nav-down header-splash-wrap header1"><div class=header-block-left><div class=mobile-menu-toggle><button id=sidebar-toggle-navigation onclick=showSidebarHandler()><svg width="1.33em" height="1.33em" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button></div><div class=version-logo-container><div class="logo-container hasinfocard_img arangodb-logo-large"><div class=logo><a href=https://www.arangodb.com/><img src=/images/logo_main.png alt=ArangoDB title></a></div></div><div class=arangodb-logo-small><a href=https://arangodb.com/><img alt="ArangoDB Logo" src=/images/ArangoDB_Logo_White_small.png></a></div></div></div><div class=container-right style=display:hidden></div><div class=search-and-version-container><a href=# class="home-link is-current" aria-label="Go to home page" onclick=goToHomepage(event)></a><div id=searchbox></div><script type=text/javascript>const SCRIPT_SRC="https://unpkg.com/@inkeep/widgets-embed@0.2.290/dist/embed.js";function loadAndInitializeInkeep(){if(document.querySelector(`script[src="${SCRIPT_SRC}]"`))return;const e=document.createElement("script");e.type="module",e.src=SCRIPT_SRC,e.onload=initializeInkeep,document.head.appendChild(e)}function initializeInkeep(){const e=Inkeep({integrationId:"clo4lx6jk0000s601cp21x2ok",apiKey:"13b4e56966a76e86c6ff359cd795ee6a0412f751d75d6383",organizationId:"org_HGBkkzGAa4KeGJGh",organizationDisplayName:"ArangoDB",primaryBrandColor:"#80a54d",stringReplacementRules:[{matchingRule:{ruleType:"Substring",string:"Arangograph"},replaceWith:"ArangoGraph"},{matchingRule:{ruleType:"Substring",string:"Aql"},replaceWith:"AQL"},{matchingRule:{ruleType:"Substring",string:"Arangodb"},replaceWith:"ArangoDB"}],customCardSettings:[{filters:{UrlMatch:{ruleType:"PartialUrl",partialUrl:"arango.qubitpi.org"}},searchTabLabel:"Official Docs"},{filters:{UrlMatch:{ruleType:"PartialUrl",partialUrl:"developer.arangodb.com"}},searchTabLabel:"Developer Hub"},{filters:{UrlMatch:{ruleType:"PartialUrl",partialUrl:"arangodb.com"}},searchTabLabel:"Home"}]}),t=e.embed({componentType:"ChatButton",properties:{stylesheetUrls:["/css/fonts.css"],fixedPositionXOffset:"52px",baseSettings:{theme:{primaryColors:{textColorOnPrimary:"white"},tokens:{fonts:{body:"'Inter'",heading:"'Inter'"},zIndex:{overlay:1e4,modal:11e3,popover:12e3,skipLink:13e3,toast:14e3,tooltip:15e3}}}},aiChatSettings:{botAvatarSrcUrl:"/images/ArangoDB_Logo_White_small.png",quickQuestions:["What can you do with AQL that is not feasible with SQL?","How do I search for objects within arrays?","Where can I deploy my ArangoDB instance?"],getHelpCallToActions:[{icon:{builtIn:"FaSlack"},name:"Slack",url:"https://arangodb-community.slack.com/"}]},searchSettings:{tabSettings:{isAllTabEnabled:!1,alwaysDisplayedTabs:["Official Docs","Developer Hub","Home"]}}}})}loadAndInitializeInkeep()</script><div class=version-selector><select id=arangodb-version onchange=changeVersion()><option value=3.13>3.13</option><option value=3.12>3.12</option><option value=3.11>3.11</option><option value=3.10>3.10</option><option value=3.9>3.9</option><option value=3.8>3.8</option></select></div></div></header><iframe src=/nav.html title=description id=menu-iframe class="menu-iframe active" style=opacity:0></iframe><div class=container-main><div class=row-main><nav id=breadcrumbs><ol class=links itemscope itemtype=http://schema.org/BreadcrumbList><meta itemprop=itemListOrder content="Descending"><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><meta itemprop=position content="3.11"><a itemprop=item class=link href=/3.11/><span itemprop=name class=breadcrumb-entry>3.11.13</span></a>
<i class="fas fa-chevron-right fa-fw"></i></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><meta itemprop=position content="Data Science"><a itemprop=item class=link href=/3.11/data-science/><span itemprop=name class=breadcrumb-entry>Data Science</span></a>
<i class="fas fa-chevron-right fa-fw"></i></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><meta itemprop=position content="Pregel"><a itemprop=item class=link href=/3.11/data-science/pregel/><span itemprop=name class=breadcrumb-entry>Pregel</span></a>
<i class="fas fa-chevron-right fa-fw"></i></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><meta itemprop=position content="Pregel Algorithms"><a itemprop=item class=link href=/3.11/data-science/pregel/algorithms/><span itemprop=name class=breadcrumb-entry>Pregel Algorithms</span></a></li></ol></nav><article class=default><hgroup><h1>Pregel Algorithms</h1><p class=lead>You can use Pregel algorithms for graph exploration, path finding, analytics queries, and much more</p></hgroup><p>Pregel algorithms are used in scenarios where you need to do an
analysis of a graph stored in ArangoDB to get insights about its
nature and structure - without having to use external processing systems.</p><p>Pregel can solve numerous graph problems and offers solutions that are
essential building blocks in the cycle of a real world application.
For example, in a network system, detecting the weaknesses of the network
design and determining the times when the network is vulnerable may
significantly reduce any downtime.</p><p>In the section below you can find more details about all available
Pregel algorithms in ArangoDB.</p><h2 id=available-algorithms>Available Algorithms <a href=/3.11/data-science/pregel/algorithms/#available-algorithms class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h2><h3 id=pagerank>PageRank <a href=/3.11/data-science/pregel/algorithms/#pagerank class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h3><p>PageRank is a well known algorithm to rank vertices in a graph: the more
important a vertex, the higher rank it gets. It goes back to L. Page and S. Brin&rsquo;s
<a href=http://infolab.stanford.edu/pub/papers/google.pdf target=_blank rel="noopener noreferrer" class=link>paper</a>&nbsp;<i class="fas fa-external-link-alt"></i> and
is used to rank pages in in search engines (hence the name). The algorithm runs
until the execution converges. To specify a custom threshold, use the <code>threshold</code>
parameter; to run for a fixed number of iterations, use the <code>maxGSS</code> parameter.</p><p>The rank of a vertex is a positive real number. The algorithm starts with every
vertex having the same rank (one divided by the number of vertices) and sends its
rank to its out-neighbors. The computation proceeds in iterations. In each iteration,
the new rank is computed according to the formula
<code>(0.15/total number of vertices) + (0.85 * the sum of all incoming ranks)</code>.
The value sent to each of the out-neighbors is the new rank divided by the number
of those neighbors, thus every out-neighbor gets the same part of the new rank.</p><p>The algorithm stops when at least one of the two conditions is satisfied:</p><ul><li>The maximum number of iterations is reached. This is the same <code>maxGSS</code>
parameter as for the other algorithms.</li><li>Every vertex changes its rank in the last iteration by less than a certain
threshold. The default threshold is 0.00001, a custom value can be set with
the <code>threshold</code> parameter.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>pregel</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s2>&#34;@arangodb/pregel&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>pregel</span><span class=p>.</span><span class=nx>start</span><span class=p>(</span><span class=s2>&#34;pagerank&#34;</span><span class=p>,</span> <span class=s2>&#34;graphname&#34;</span><span class=p>,</span> <span class=p>{</span> <span class=nx>maxGSS</span><span class=o>:</span> <span class=mi>100</span><span class=p>,</span> <span class=nx>threshold</span><span class=o>:</span> <span class=mf>0.00000001</span><span class=p>,</span> <span class=nx>resultField</span><span class=o>:</span> <span class=s2>&#34;rank&#34;</span> <span class=p>})</span></span></span></code></pre></div><h4 id=seeded-pagerank>Seeded PageRank <a href=/3.11/data-science/pregel/algorithms/#seeded-pagerank class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h4><p>It is possible to specify an initial distribution for the vertex documents in
your graph. To define these seed ranks / centralities, you can specify a
<code>sourceField</code> in the properties for this algorithm. If the specified field is
set on a document <em>and</em> the value is numeric, then it is used instead of
the default initial rank of <code>1 / numVertices</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>pregel</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s2>&#34;@arangodb/pregel&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>pregel</span><span class=p>.</span><span class=nx>start</span><span class=p>(</span><span class=s2>&#34;pagerank&#34;</span><span class=p>,</span> <span class=s2>&#34;graphname&#34;</span><span class=p>,</span> <span class=p>{</span> <span class=nx>maxGSS</span><span class=o>:</span> <span class=mi>20</span><span class=p>,</span> <span class=nx>threshold</span><span class=o>:</span> <span class=mf>0.00000001</span><span class=p>,</span> <span class=nx>sourceField</span><span class=o>:</span> <span class=s2>&#34;seed&#34;</span><span class=p>,</span> <span class=nx>resultField</span><span class=o>:</span> <span class=s2>&#34;rank&#34;</span> <span class=p>})</span></span></span></code></pre></div><h3 id=single-source-shortest-path>Single-Source Shortest Path <a href=/3.11/data-science/pregel/algorithms/#single-source-shortest-path class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h3><p>Calculates the distances, that is, the lengths of shortest paths from the
given source to all other vertices, called <em>targets</em>. The result is written
to the specified property of the respective target.
The distance to the source vertex itself is returned as <code>0</code> and a length above
<code>9007199254740991</code> (max safe integer) means that there is no path from the
source to the vertex in the graph.</p><p>The algorithm runs until all distances are computed. The number of iterations is bounded by the
diameter of your graph (the longest distance between two vertices).</p><p>A call of the algorithm requires the <code>source</code> parameter whose value is the
document ID of the source vertex. The result field needs to be
specified in <code>_resultField</code> (note the underscore).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>pregel</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s2>&#34;@arangodb/pregel&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>pregel</span><span class=p>.</span><span class=nx>start</span><span class=p>(</span><span class=s2>&#34;sssp&#34;</span><span class=p>,</span> <span class=s2>&#34;graphname&#34;</span><span class=p>,</span> <span class=p>{</span> <span class=nx>source</span><span class=o>:</span> <span class=s2>&#34;vertices/1337&#34;</span><span class=p>,</span> <span class=nx>_resultField</span><span class=o>:</span> <span class=s2>&#34;distance&#34;</span> <span class=p>});</span></span></span></code></pre></div><h3 id=connected-components>Connected Components <a href=/3.11/data-science/pregel/algorithms/#connected-components class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h3><p>There are three algorithms to find connected components in a graph:</p><ol><li><p>If your graph is effectively undirected (for every edge from vertex A to
vertex B there is also an edge from B to A),
then the simple <strong>connected components</strong> algorithm named
<code>"connectedcomponents"</code> is suitable.</p><p>It is a very simple and fast algorithm, but it only works correctly on
undirected graphs. Your results on directed graphs may vary, depending on
how connected your components are.</p><p>In an undirected graph, a <em>connected component</em> is a subgraph:</p><ul><li>where there is a path between every pair of vertices from this component and</li><li>which is maximal with this property: adding any other vertex would destroy it.
In other words, there is no path between any vertex from the component and
any vertex not in the component.</li></ul></li><li><p>To find <strong>weakly connected components</strong> (WCC) you can use the algorithm named <code>"wcc"</code>.
A <em>weakly connected component</em> in a directed graph is a maximal subgraph such
that there is a path between each pair of vertices
where <em>we can walk also against the direction of edges</em>. More formally, it is
a connected component (see the definition above) in the
<em>underlying undirected graph</em>, i.e., in the undirected graph obtained by
adding an edge from vertex B to vertex A (if it does not already exist),
if there is an edge from vertex A to vertex B.</p><p>This algorithm works on directed graphs but, in general, requires a greater amount of
traffic between DB-Servers.</p></li><li><p>To find <strong>strongly connected components</strong> (SCC) you can use the algorithm named <code>"scc"</code>.
A <em>strongly connected component</em> is a maximal subgraph,
where for every two vertices, there is a path from one of them to the other.
It is thus defined as a weakly connected component,
but one is not allowed to run against the edge directions.</p><p>The algorithm is more complex than the WCC algorithm and, in general, requires more memory.</p></li></ol><p>All above algorithms assign a component ID to each vertex, a number which is
written into the specified <code>resultField</code>. All vertices from the same component
obtain the same component ID, every two vertices from different components
obtain different IDs.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>pregel</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s2>&#34;@arangodb/pregel&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// connected components
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>pregel</span><span class=p>.</span><span class=nx>start</span><span class=p>(</span><span class=s2>&#34;connectedcomponents&#34;</span><span class=p>,</span> <span class=s2>&#34;graphname&#34;</span><span class=p>,</span> <span class=p>{</span> <span class=nx>resultField</span><span class=o>:</span> <span class=s2>&#34;component&#34;</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// weakly connected components
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>pregel</span><span class=p>.</span><span class=nx>start</span><span class=p>(</span><span class=s2>&#34;wcc&#34;</span><span class=p>,</span> <span class=s2>&#34;graphname&#34;</span><span class=p>,</span> <span class=p>{</span> <span class=nx>resultField</span><span class=o>:</span> <span class=s2>&#34;component_weak&#34;</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// strongly connected components
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>pregel</span><span class=p>.</span><span class=nx>start</span><span class=p>(</span><span class=s2>&#34;scc&#34;</span><span class=p>,</span> <span class=s2>&#34;graphname&#34;</span><span class=p>,</span> <span class=p>{</span> <span class=nx>resultField</span><span class=o>:</span> <span class=s2>&#34;component_strong&#34;</span> <span class=p>});</span></span></span></code></pre></div><h3 id=hyperlink-induced-topic-search-hits>Hyperlink-Induced Topic Search (HITS) <a href=/3.11/data-science/pregel/algorithms/#hyperlink-induced-topic-search-hits class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h3><p>HITS is a link analysis algorithm that rates Web pages, developed by
Jon Kleinberg in J. Kleinberg,
<a href=http://www.cs.cornell.edu/home/kleinber/auth.pdf target=_blank rel="noopener noreferrer" class=link>Authoritative sources in a hyperlinked environment</a>&nbsp;<i class="fas fa-external-link-alt"></i>,
Journal of the ACM. 46 (5): 604–632, 1999. The algorithm is also known as <em>Hubs and Authorities</em>.</p><p>The idea behind hubs and authorities comes from the typical structure of the early web:
certain websites, known as hubs, serve as large directories that are not actually
authoritative on the information that they point to. These hubs are used as
compilations of a broad catalog of information that leads users to other,
authoritative, webpages.</p><p>The algorithm assigns two scores to each vertex: the authority score and the
hub score. The authority score of a vertex rates the total hub score of vertices
pointing to that vertex; the hub score rates the total authority
score of vertices pointed by it. Also see
<a href=https://en.wikipedia.org/wiki/HITS_algorithm target=_blank rel="noopener noreferrer" class=link>en.wikipedia.org/wiki/HITS_algorithm</a>&nbsp;<i class="fas fa-external-link-alt"></i>.
Note, however, that this version of the algorithm is slightly different from that of the original paper.</p><p>ArangoDB offers two versions of the algorithm: the original Kleinberg&rsquo;s version and our own version
that has some advantages and disadvantages as discussed below.</p><p>Both versions keep two values for each vertex: the hub value and the authority value and update
both of them in iterations until the corresponding sequences converge or until the maximum number of steps
is reached. The hub value of a vertex is updated from the authority values of the vertices pointed by it;
the authority value is updated from the hub values of the vertices pointing to it.</p><p>The differences of the two versions are technical (and we omit the tedious description here)
but have some less technical implications:</p><ul><li>The original version needs twice as many global super-steps as our version.</li><li>The original version is guaranteed to converge, our version may also converge, but there are examples
where it does not (for instance, on undirected stars).</li><li>In the original version, the output values are normed in the sense that the sum of their squared values
is 1, our version does not guarantee that.</li></ul><p>In a call of either version, the <code>threshold</code> parameter can be used to set a limit for the convergence
(measured as the maximum absolute difference of the hub and authority scores
between the current and last iteration).</p><p>If the value of the result field is <code>&lt;resultField></code>, then the hub score is stored in
the <code>&lt;resultField>_hub</code> field and the authority score in the <code>&lt;resultField>_auth</code> field.</p><p>The algorithm can be executed like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>pregel</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s2>&#34;@arangodb/pregel&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>jobId</span> <span class=o>=</span> <span class=nx>pregel</span><span class=p>.</span><span class=nx>start</span><span class=p>(</span><span class=s2>&#34;hits&#34;</span><span class=p>,</span> <span class=s2>&#34;graphname&#34;</span><span class=p>,</span> <span class=p>{</span> <span class=nx>threshold</span><span class=o>:</span><span class=mf>0.00001</span><span class=p>,</span> <span class=nx>resultField</span><span class=o>:</span> <span class=s2>&#34;score&#34;</span> <span class=p>});</span></span></span></code></pre></div><p>for ArangoDB&rsquo;s version and</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>pregel</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s2>&#34;@arangodb/pregel&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>jobId</span> <span class=o>=</span> <span class=nx>pregel</span><span class=p>.</span><span class=nx>start</span><span class=p>(</span><span class=s2>&#34;hitskleinberg&#34;</span><span class=p>,</span> <span class=s2>&#34;graphname&#34;</span><span class=p>,</span> <span class=p>{</span> <span class=nx>threshold</span><span class=o>:</span><span class=mf>0.00001</span><span class=p>,</span> <span class=nx>resultField</span><span class=o>:</span> <span class=s2>&#34;score&#34;</span> <span class=p>});</span></span></span></code></pre></div><p>for the original version.</p><h3 id=vertex-centrality>Vertex Centrality <a href=/3.11/data-science/pregel/algorithms/#vertex-centrality class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h3><p>Centrality measures help identify the most important vertices in a graph.
They can be used in a wide range of applications:
to identify influencers in social networks, or middlemen in terrorist
networks.</p><p>There are various definitions for centrality, the simplest one being the
vertex degree. These definitions were not designed with scalability in mind.
It is probably impossible to discover an efficient algorithm which computes
them in a distributed way. Fortunately there are scalable substitutions
available, which should be equally usable for most use cases.</p><p><figure class=image-caption><img alt="Illustration of an execution of different centrality measures (Freeman 1977)" src=/images/centrality_visual.png><figcaption></figcaption></figure></p><h4 id=effective-closeness>Effective Closeness <a href=/3.11/data-science/pregel/algorithms/#effective-closeness class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h4><p>A common definitions of centrality is the <strong>closeness centrality</strong>
(or closeness). The closeness of a vertex in a graph is the inverse average
length of the shortest path between the vertex and all other vertices.
For vertices <em>x</em>, <em>y</em> and shortest distance <code>d(y, x)</code> it is defined as:</p><p><figure class=image-caption><img alt="Vertex Closeness Formula" src=/images/closeness.png><figcaption></figcaption></figure></p><p>Effective Closeness approximates the closeness measure. The algorithm works by
iteratively estimating the number of shortest paths passing through each vertex.
The score approximates the real closeness score, since it is not possible
to actually count all shortest paths due to the horrendous <code>O(n^2 * d)</code> memory
requirements. The algorithm is from the paper
<em>Centralities in Large Networks: Algorithms and Observations (U Kang et.al. 2011)</em>.</p><p>ArangoDBs implementation approximates the number of shortest path in each
iteration by using a HyperLogLog counter with 64 buckets. This should work well
on large graphs and on smaller ones as well. The memory requirements should be
<strong>O(n * d)</strong> where <em>n</em> is the number of vertices and <em>d</em> the diameter of your
graph. Each vertex stores a counter for each iteration of the algorithm.</p><p>The algorithm can be used like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>pregel</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s2>&#34;@arangodb/pregel&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>jobId</span> <span class=o>=</span> <span class=nx>pregel</span><span class=p>.</span><span class=nx>start</span><span class=p>(</span><span class=s2>&#34;effectivecloseness&#34;</span><span class=p>,</span> <span class=s2>&#34;graphname&#34;</span><span class=p>,</span> <span class=p>{</span> <span class=nx>resultField</span><span class=o>:</span> <span class=s2>&#34;closeness&#34;</span> <span class=p>});</span></span></span></code></pre></div><h4 id=linerank>LineRank <a href=/3.11/data-science/pregel/algorithms/#linerank class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h4><p>Another common measure is the <a href=https://en.wikipedia.org/wiki/Betweenness_centrality target=_blank rel="noopener noreferrer" class=link><em>betweenness</em> centrality</a>&nbsp;<i class="fas fa-external-link-alt"></i>:
It measures the number of times a vertex is part of shortest paths between any
pairs of vertices. For a vertex <em>v</em> betweenness is defined as:</p><p><figure class=image-caption><img alt="Vertex Betweenness Formula" src=/images/betweenness.png><figcaption></figcaption></figure></p><p>Where the σ represents the number of shortest paths between <em>x</em> and <em>y</em>,
and σ(v) represents the number of paths also passing through a vertex <em>v</em>.
By intuition a vertex with higher betweenness centrality has more
information passing through it.</p><p><strong>LineRank</strong> approximates the random walk betweenness of every vertex in a
graph. This is the probability that someone, starting on an arbitrary vertex,
visits this node when they randomly choose edges to visit.</p><p>The algorithm essentially builds a line graph out of your graph
(switches the vertices and edges), and then computes a score similar to PageRank.
This can be considered a scalable equivalent to vertex betweenness, which can
be executed distributedly in ArangoDB. The algorithm is from the paper
<em>Centralities in Large Networks: Algorithms and Observations (U Kang et.al. 2011)</em>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>pregel</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s2>&#34;@arangodb/pregel&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>jobId</span> <span class=o>=</span> <span class=nx>pregel</span><span class=p>.</span><span class=nx>start</span><span class=p>(</span><span class=s2>&#34;linerank&#34;</span><span class=p>,</span> <span class=s2>&#34;graphname&#34;</span><span class=p>,</span> <span class=p>{</span> <span class=nx>resultField</span><span class=o>:</span> <span class=s2>&#34;linerank&#34;</span> <span class=p>});</span></span></span></code></pre></div><h3 id=community-detection>Community Detection <a href=/3.11/data-science/pregel/algorithms/#community-detection class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h3><p>Graphs based on real world networks often have a community structure.
This means it is possible to find groups of vertices such that each vertex
group is internally more densely connected than outside the group.
This has many applications when you want to analyze your networks, for example
Social networks include community groups (the origin of the term, in fact)
based on common location, interests, occupation, etc.</p><h4 id=label-propagation>Label Propagation <a href=/3.11/data-science/pregel/algorithms/#label-propagation class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h4><p><em>Label Propagation</em> can be used to implement community detection on large
graphs. The algorithm assigns a community, more precisely, a Community ID
(a natural number), to every vertex in the graph.
The idea is that each vertex should be in the community that most of
its neighbors are in.</p><p>At first, the algorithm assigns unique initial Community IDs to the vertices.
The assignment is deterministic given the graph and the distribution of vertices
on the shards, but there is no guarantee that a vertex obtains
the same initial ID in two different runs of the algorithm, even if the graph does not change
(because the sharding may change). Moreover, there is no guarantee on a particular
distribution of the initial IDs over the vertices.</p><p>Then, in each iteration, a vertex sends its current Community
ID to all its neighbor vertices. After that each vertex adopts the Community ID it
received most frequently in the last step.</p><p>Note that, in a usual implementation of Label Propagation, if there are
multiple most frequently received Community IDs, one is chosen randomly.
An advantage of our implementation is that this choice is deterministic.
This comes for the price that the choice rules are somewhat involved:
If a vertex obtains only one ID and the ID of the vertex from the previous step,
its old ID, is less than the obtained ID, the old ID is kept.
(IDs are numbers and thus comparable to each other.) If a vertex obtains
more than one ID, its new ID is the lowest ID among the most frequently
obtained IDs. (For example, if the obtained IDs are 1, 2, 2, 3, 3,
then 2 is the new ID.) If, however, no ID arrives more than once, the new ID is
the minimum of the lowest obtained IDs and the old ID. (For example, if the
old ID is 5 and the obtained IDs are 3, 4, 6, then the new ID is 3.
If the old ID is 2, it is kept.)</p><p>If a vertex keeps its ID 20 times or more in a row, it does not send its ID.
Vertices that did not obtain any IDs do not update their ID and do not send it.</p><p>The algorithm runs until it converges, which likely never really happens on
large graphs. Therefore you need to specify a maximum iteration bound.
The default bound is 500 iterations, which is too large for
common applications.</p><p>The algorithm should work best on undirected graphs. On directed
graphs, the resulting partition into communities might change, if the number
of performed steps changes. How strong the dependence is
may be influenced by the density of the graph.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>pregel</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s2>&#34;@arangodb/pregel&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>jobId</span> <span class=o>=</span> <span class=nx>pregel</span><span class=p>.</span><span class=nx>start</span><span class=p>(</span><span class=s2>&#34;labelpropagation&#34;</span><span class=p>,</span> <span class=s2>&#34;graphname&#34;</span><span class=p>,</span> <span class=p>{</span> <span class=nx>maxGSS</span><span class=o>:</span> <span class=mi>100</span><span class=p>,</span> <span class=nx>resultField</span><span class=o>:</span> <span class=s2>&#34;community&#34;</span> <span class=p>});</span></span></span></code></pre></div><h4 id=speaker-listener-label-propagation>Speaker-Listener Label Propagation <a href=/3.11/data-science/pregel/algorithms/#speaker-listener-label-propagation class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h4><p>The <a href=https://arxiv.org/pdf/1109.5720.pdf target=_blank rel="noopener noreferrer" class=link>Speaker-listener Label Propagation</a>&nbsp;<i class="fas fa-external-link-alt"></i>
(SLPA) can be used to implement community detection. It works similar to the
label propagation algorithm, but now every node additionally accumulates a
memory of observed labels (instead of forgetting all but one label).</p><p>Before the algorithm run, every vertex is initialized with an unique ID
(the initial community label).
During the run three steps are executed for each vertex:</p><ol><li>Current vertex is the listener, all other vertices are speakers.</li><li>Each speaker sends out a label from memory, we send out a random label with a
probability proportional to the number of times the vertex observed the label.</li><li>The listener remembers one of the labels, we always choose the most
frequently observed label.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>pregel</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s2>&#34;@arangodb/pregel&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>jobId</span> <span class=o>=</span> <span class=nx>pregel</span><span class=p>.</span><span class=nx>start</span><span class=p>(</span><span class=s2>&#34;slpa&#34;</span><span class=p>,</span> <span class=s2>&#34;graphname&#34;</span><span class=p>,</span> <span class=p>{</span> <span class=nx>maxGSS</span><span class=o>:</span><span class=mi>100</span><span class=p>,</span> <span class=nx>resultField</span><span class=o>:</span> <span class=s2>&#34;community&#34;</span> <span class=p>});</span></span></span></code></pre></div><p>You can also execute SLPA with the <code>maxCommunities</code> parameter to limit the
number of output communities. Internally the algorithm still keeps the
memory of all labels, but the output is reduced to just the <code>n</code> most frequently
observed labels.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>pregel</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s2>&#34;@arangodb/pregel&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>jobId</span> <span class=o>=</span> <span class=nx>pregel</span><span class=p>.</span><span class=nx>start</span><span class=p>(</span><span class=s2>&#34;slpa&#34;</span><span class=p>,</span> <span class=s2>&#34;graphname&#34;</span><span class=p>,</span> <span class=p>{</span> <span class=nx>maxGSS</span><span class=o>:</span> <span class=mi>100</span><span class=p>,</span> <span class=nx>resultField</span><span class=o>:</span> <span class=s2>&#34;community&#34;</span><span class=p>,</span> <span class=nx>maxCommunities</span><span class=o>:</span> <span class=mi>1</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=c1>// check the status periodically for completion
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>pregel</span><span class=p>.</span><span class=nx>status</span><span class=p>(</span><span class=nx>jobId</span><span class=p>);</span></span></span></code></pre></div><nav class=pagination><span class=prev><a class="nav nav-prev link" href=/3.11/data-science/pregel/><i class="fas fa-chevron-left fa-fw"></i><p>Pregel</p></a></span><span class=next><a class="nav nav-next link" href=/3.11/data-science/adapters/><p>Adapters</p><i class="fas fa-chevron-right fa-fw"></i></a></span></nav></article><div class=toc-container><a class=edit-page aria-label href=https://github.com/arangodb/docs-hugo/edit/main/site/content/3.11/data-science/pregel/algorithms.md target=_blank><i class="fab fa-fw fa-github edit-page-icon"></i></a><div class=toc><div class=toc-content><div class=toc-header><p>On this page</p></div><nav id=TableOfContents><div class=level-2><a href=#available-algorithms>Available Algorithms</a></div><div class=level-3><a href=#pagerank>PageRank</a></div><div class=level-4><a href=#seeded-pagerank>Seeded PageRank</a></div><div class=level-3><a href=#single-source-shortest-path>Single-Source Shortest Path</a></div><div class=level-3><a href=#connected-components>Connected Components</a></div><div class=level-3><a href=#hyperlink-induced-topic-search-hits>Hyperlink-Induced Topic Search (HITS)</a></div><div class=level-3><a href=#vertex-centrality>Vertex Centrality</a></div><div class=level-4><a href=#effective-closeness>Effective Closeness</a></div><div class=level-4><a href=#linerank>LineRank</a></div><div class=level-3><a href=#community-detection>Community Detection</a></div><div class=level-4><a href=#label-propagation>Label Propagation</a></div><div class=level-4><a href=#speaker-listener-label-propagation>Speaker-Listener Label Propagation</a></div></nav></div></div></div></div></div></section></section></div><button class="back-to-top hidden" onclick=goToTop(event) href=#><i class="fa fa-arrow-up"></i></button><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@docsearch/css@3>
<script src=https://cdn.jsdelivr.net/npm/@docsearch/js@3></script>
<script type=text/javascript>window.setupDocSearch=function(e){if(!window.docsearch)return;docsearch({appId:"OK3ZBQ5982",apiKey:"500c85ccecb335d507fe4449aed12e1d",indexName:"arangodbdocs",insights:!0,container:"#searchbox",debug:!1,maxResultsPerGroup:10,searchParameters:{facetFilters:[`version:${e}`]}})}</script></body></html>