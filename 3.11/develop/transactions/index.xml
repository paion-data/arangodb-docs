<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Transactions on ArangoDB Documentation</title><link>http://localhost/3.11/develop/transactions/</link><description>Recent content in Transactions on ArangoDB Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://localhost/3.11/develop/transactions/index.xml" rel="self" type="application/rss+xml"/><item><title>JavaScript Transactions</title><link>http://localhost/3.11/develop/transactions/javascript-transactions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/develop/transactions/javascript-transactions/</guid><description>JavaScript transactions are different from transactions in SQL.
In SQL, transactions are started with explicit BEGIN or START TRANSACTION command. Following any series of data retrieval or modification operations, an SQL transaction is finished with a COMMIT command, or rolled back with a ROLLBACK command. There may be client/server communication between the start and the commit/rollback of an SQL transaction.
In ArangoDB, a transaction is always a server-side operation, and is executed on the server in one go, without any client interaction.</description></item><item><title>Stream Transactions</title><link>http://localhost/3.11/develop/transactions/stream-transactions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/develop/transactions/stream-transactions/</guid><description>Stream Transactions allow you to perform multi-document transaction with individual begin and commit / abort commands. This is comparable to the BEGIN, COMMIT and ROLLBACK operations found in relational database systems.
Stream Transaction work in conjunction with other operations in ArangoDB. Supported operations include:
Read and write documents Get the number of documents of collections Truncate collections Run AQL queries You always need to start the transaction first and explicitly specify the collections used for write accesses upfront.</description></item><item><title>Locking and isolation of transactions</title><link>http://localhost/3.11/develop/transactions/locking-and-isolation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/develop/transactions/locking-and-isolation/</guid><description>Transactions need to specify from which collections they will read data and which collections they intend to modify. This can be done by setting the read, write, or exclusive attributes in the collections attribute of the transaction:
db._executeTransaction({ collections: { read: &amp;#34;users&amp;#34;, write: [&amp;#34;test&amp;#34;, &amp;#34;log&amp;#34;] }, action: function () { const db = require(&amp;#34;@arangodb&amp;#34;).db; db.users.toArray().forEach(function(doc) { db.log.insert({ value: &amp;#34;removed user: &amp;#34; + doc.name }); db.test.remove(doc._key); }); } }); write here means write access to the collection, and also includes any read accesses.</description></item><item><title>Durability of transactions</title><link>http://localhost/3.11/develop/transactions/durability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/develop/transactions/durability/</guid><description>Transactions are executed until there is either a rollback or a commit. On rollback, the operations from the transaction are reversed.
The RocksDB storage engine applies operations of a transaction in main memory only until they are committed. In case of an a rollback the entire transaction is just cleared, no extra rollback steps are required.
In the event of a server crash, the storage engine scans the write-ahead log to restore certain meta-data like the number of documents in collection or the selectivity estimates of secondary indexes.</description></item><item><title>Limitations of transactions</title><link>http://localhost/3.11/develop/transactions/limitations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.11/develop/transactions/limitations/</guid><description>In General Transactions in ArangoDB have been designed with particular use cases in mind. They will be mainly useful for short and small data retrieval and/or modification operations.
The implementation is not optimized for very long-running or very voluminous operations, and may not be usable for these cases.
One limitation is that a transaction operation information must fit into main memory. The transaction information consists of record pointers, revision numbers and rollback information.</description></item></channel></rss>