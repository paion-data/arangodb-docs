<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AQL Fundamentals on ArangoDB Documentation</title><link>http://localhost/3.10/aql/fundamentals/</link><description>Recent content in AQL Fundamentals on ArangoDB Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://localhost/3.10/aql/fundamentals/index.xml" rel="self" type="application/rss+xml"/><item><title>AQL Syntax</title><link>http://localhost/3.10/aql/fundamentals/syntax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/fundamentals/syntax/</guid><description>Query types An AQL query must either return a result (indicated by usage of the RETURN keyword) or execute a data-modification operation (indicated by usage of one of the keywords INSERT, UPDATE, REPLACE, REMOVE or UPSERT). The AQL parser will return an error if it detects more than one data-modification operation in the same query or if it cannot figure out if the query is meant to be a data retrieval or a modification operation.</description></item><item><title>Data types in AQL</title><link>http://localhost/3.10/aql/fundamentals/data-types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/fundamentals/data-types/</guid><description>The following types are available:
Data type Description null An empty value, also: the absence of a value boolean Boolean truth value with possible values false and true number Signed (real) number string UTF-8 encoded text value array / list Sequence of values, referred to by their positions object / document Sequence of values, referred to by their names Primitive types Null value A null value can be used to represent an empty or absent value.</description></item><item><title>Bind parameters in AQL</title><link>http://localhost/3.10/aql/fundamentals/bind-parameters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/fundamentals/bind-parameters/</guid><description>It is good practice to separate the query text from the literal values because it prevents (malicious) injection of keywords and other collection names into an existing query. This injection would be dangerous because it may change the meaning of an existing query.
Using bind parameters, the meaning of an existing query cannot be changed. Bind parameters can be used everywhere in a query where literals can be used. This lets you turn literals into a sort of variables to reuse the same query with different parameterization.</description></item><item><title>Type and value order in AQL</title><link>http://localhost/3.10/aql/fundamentals/type-and-value-order/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/fundamentals/type-and-value-order/</guid><description>When checking for equality or inequality, or when determining the sort order of values, AQL uses a deterministic algorithm for the comparison.
The compared operands are first compared by their data types, and only by their data values if the operands have the same data types.
The following type order is used when comparing data types:
null &amp;lt; bool &amp;lt; number &amp;lt; string &amp;lt; array (or list) &amp;lt; object (or document) This means null is the smallest type in AQL and object is the type with the highest order.</description></item><item><title>Accessing data from collections with AQL</title><link>http://localhost/3.10/aql/fundamentals/accessing-data-from-collections/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/fundamentals/accessing-data-from-collections/</guid><description>A collection can be thought of as an array of documents. To access the documents, use a FOR operation to iterate over a collection using its name, like FOR doc IN collection ....
Note that when iterating over a collection, the order of documents is undefined. To establish an explicit and deterministic order for the documents, use a SORT operation in addition.
Data in collections is stored in documents, which are JSON objects.</description></item><item><title>Combining queries with subqueries in AQL</title><link>http://localhost/3.10/aql/fundamentals/subqueries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/fundamentals/subqueries/</guid><description>How to use subqueries Wherever an expression is allowed in AQL, a subquery can be placed. A subquery is a query part that can introduce its own local variables without affecting variables and values in its outer scope(s).
It is required that subqueries be put inside parentheses ( and ) to explicitly mark their start and end points:
FOR p IN persons LET recommendations = ( // subquery start FOR r IN recommendations FILTER p.</description></item><item><title>AQL query results</title><link>http://localhost/3.10/aql/fundamentals/query-results/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/fundamentals/query-results/</guid><description>AQL queries and also subqueries each produce an array with zero or more elements.
An empty array typically means that no (matching) data was found to act upon, or that a write query didn&amp;rsquo;t specify anything to return.
FOR doc IN emptyCollection RETURN doc // no documents FOR u IN users FILTER age == -1 // no matches RETURN u UPDATE { id: 2, active: true } IN users // no RETURN operation The result set of the above examples is empty:</description></item><item><title>AQL query errors</title><link>http://localhost/3.10/aql/fundamentals/query-errors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/fundamentals/query-errors/</guid><description>Issuing an invalid query to the server results in a parse error if the query is syntactically invalid. ArangoDB detects such errors during query inspection and aborts further processing. The error number and an error message are returned so that you can fix the errors.
If a query passes the parsing stage, all collections explicitly referenced in the query are known. If any of these collections doesn&amp;rsquo;t exist, the query execution is aborted and an appropriate error message is returned.</description></item><item><title>Known limitations for AQL queries</title><link>http://localhost/3.10/aql/fundamentals/limitations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/fundamentals/limitations/</guid><description>Complexity limitations The following hard-coded limitations exist for AQL queries:
An AQL query cannot use more than 1000 result registers. One result register is needed for every named query variable and for internal/anonymous query variables, e.g. for intermediate results. Subqueries also require result registers. An AQL query cannot have more than 4000 execution nodes in its initial query execution plan. This number includes all execution nodes of the initial execution plan, even if some of them could be optimized away later by the query optimizer during plan optimization.</description></item></channel></rss>