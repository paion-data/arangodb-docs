<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>High-level AQL operations on ArangoDB Documentation</title><link>http://localhost/3.10/aql/high-level-operations/</link><description>Recent content in High-level AQL operations on ArangoDB Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://localhost/3.10/aql/high-level-operations/index.xml" rel="self" type="application/rss+xml"/><item><title>`FOR` operation in AQL</title><link>http://localhost/3.10/aql/high-level-operations/for/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/high-level-operations/for/</guid><description>Syntax The general syntax for iterating over collections and arrays is:
FOR variableName IN expression There is also a special variant for graph traversals:
FOR vertexVariableName [, edgeVariableName [, pathVariableName ] ] IN traversalExpression For Views, there is a special (optional) SEARCH keyword:
FOR variableName IN viewName SEARCH searchExpression Views cannot be used as edge collections in traversals:
FOR v IN 1..3 ANY startVertex viewName /* invalid! */ All variants can optionally end with an OPTIONS { … } clause.</description></item><item><title>`RETURN` operation in AQL</title><link>http://localhost/3.10/aql/high-level-operations/return/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/high-level-operations/return/</guid><description>A RETURN operation is mandatory at the end of each block in a data access query, otherwise the query result would be undefined. Using RETURN at the top level in data modification queries is optional.
Syntax The general syntax for RETURN is:
RETURN expression There is also a variant RETURN DISTINCT.
The expression returned by RETURN is produced for each iteration in the block the RETURN statement is placed in. That means the result of a RETURN statement is always an array.</description></item><item><title>`FILTER` operation in AQL</title><link>http://localhost/3.10/aql/high-level-operations/filter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/high-level-operations/filter/</guid><description>Syntax FILTER expression expression must be a condition that evaluates to either false or true.
Usage If the condition result is false, the current element is skipped, so it will not be processed further and not be part of the result. If the condition is true, the current element is not skipped and can be further processed.
See Operators for a list of comparison operators, logical operators etc. that you can use in conditions.</description></item><item><title>`SEARCH` operation in AQL</title><link>http://localhost/3.10/aql/high-level-operations/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/high-level-operations/search/</guid><description>The SEARCH operation guarantees to use View indexes for an efficient execution plan. If you use the FILTER keyword for Views, no indexes are utilized and the filtering is performed as a post-processing step.
Conceptually, a View is just another document data source, similar to an array or a document/edge collection, over which you can iterate using a FOR operation in AQL:
FOR doc IN viewName RETURN doc The optional SEARCH operation provides the capabilities to:</description></item><item><title>`SORT` operation in AQL</title><link>http://localhost/3.10/aql/high-level-operations/sort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/high-level-operations/sort/</guid><description>Syntax The general syntax is:
SORT expression direction Usage The SORT operation sorts the already produced intermediate results of the current block. For example, the following query sorts by lastName (in ascending order), then firstName (in ascending order), then by id (in descending order):
FOR u IN users SORT u.lastName, u.firstName, u.id DESC RETURN u Specifying the direction is optional. The default (implicit) direction for a sort expression is the ascending order.</description></item><item><title>`LIMIT` operation in AQL</title><link>http://localhost/3.10/aql/high-level-operations/limit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/high-level-operations/limit/</guid><description>Syntax Two general forms of LIMIT are:
LIMIT count LIMIT offset, count The first form allows specifying only the count value whereas the second form allows specifying both offset and count. The first form is identical using the second form with an offset value of 0.
Usage FOR u IN users LIMIT 5 RETURN u Above query returns five documents of the users collection. It could also be written as LIMIT 0, 5 for the same result.</description></item><item><title>`LET` operation in AQL</title><link>http://localhost/3.10/aql/high-level-operations/let/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/high-level-operations/let/</guid><description>The variable is introduced in the scope the LET statement is placed in. You cannot change the value once assigned.
Syntax LET variableName = expression expression can be a simple expression or a subquery.
For allowed variable names AQL Syntax.
Usage Variables are immutable in AQL, which means they cannot be re-assigned:
LET a = [1, 2, 3] // initial assignment a = PUSH(a, 4) // syntax error, unexpected identifier LET a = PUSH(a, 4) // parsing error, variable &amp;#39;a&amp;#39; is assigned multiple times LET b = PUSH(a, 4) // allowed, result: [1, 2, 3, 4] LET statements are mostly used to declare complex computations and to avoid repeated computations of the same value at multiple parts of a query.</description></item><item><title>`COLLECT` operation in AQL</title><link>http://localhost/3.10/aql/high-level-operations/collect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/high-level-operations/collect/</guid><description>The different variants of COLLECT cover most needs for grouping and aggregating data. For aggregation using a sliding window, see the WINDOW operation.
Syntax There are several syntax variants for COLLECT operations:
COLLECT variableName = expression COLLECT variableName = expression INTO groupsVariable COLLECT variableName = expression INTO groupsVariable = projectionExpression COLLECT variableName = expression INTO groupsVariable KEEP keepVariable COLLECT variableName = expression WITH COUNT INTO countVariable COLLECT variableName = expression AGGREGATE variableName = aggregateExpression COLLECT variableName = expression AGGREGATE variableName = aggregateExpression INTO groupsVariable COLLECT AGGREGATE variableName = aggregateExpression COLLECT AGGREGATE variableName = aggregateExpression INTO groupsVariable COLLECT WITH COUNT INTO countVariable All variants can optionally end with an OPTIONS { … } clause.</description></item><item><title>`WINDOW` operation in AQL</title><link>http://localhost/3.10/aql/high-level-operations/window/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/high-level-operations/window/</guid><description>The WINDOW operation can be used for aggregations over adjacent documents, or preceding and / or following rows in other words. It can also aggregate based on a value or duration range relative to a document attribute.
The operation performs a COLLECT AGGREGATE-like operation on a set of query rows. However, whereas a COLLECT operation groups multiple query rows into a single result group, a WINDOW operation produces a result for each query row:</description></item><item><title>`REMOVE` operation in AQL</title><link>http://localhost/3.10/aql/high-level-operations/remove/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/high-level-operations/remove/</guid><description>Each REMOVE operation is restricted to a single collection, and the collection name must not be dynamic. Only a single REMOVE statement per collection is allowed per AQL query, and it cannot be followed by read or write operations that access the same collection, by traversal operations, or AQL functions that can read documents.
Syntax The syntax for a remove operation is:
REMOVE keyExpression IN collection It can optionally end with an OPTIONS { … } clause.</description></item><item><title>`UPDATE` operation in AQL</title><link>http://localhost/3.10/aql/high-level-operations/update/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/high-level-operations/update/</guid><description>Each UPDATE operation is restricted to a single collection, and the collection name must not be dynamic. Only a single UPDATE statement per collection is allowed per AQL query, and it cannot be followed by read or write operations that access the same collection, by traversal operations, or AQL functions that can read documents.
You cannot update the _id, _key, and _rev system attributes, but you can update the _from and _to attributes.</description></item><item><title>`REPLACE` operation in AQL</title><link>http://localhost/3.10/aql/high-level-operations/replace/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/high-level-operations/replace/</guid><description>Each REPLACE operation is restricted to a single collection, and the collection name must not be dynamic. Only a single REPLACE statement per collection is allowed per AQL query, and it cannot be followed by read or write operations that access the same collection, by traversal operations, or AQL functions that can read documents.
You cannot replace the _id, _key, and _rev system attributes, but you can replace the _from and _to attributes.</description></item><item><title>`INSERT` operation in AQL</title><link>http://localhost/3.10/aql/high-level-operations/insert/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/high-level-operations/insert/</guid><description>Each INSERT operation is restricted to a single collection, and the collection name must not be dynamic. Only a single INSERT statement per collection is allowed per AQL query, and it cannot be followed by read or write operations that access the same collection, by traversal operations, or AQL functions that can read documents.
Syntax The syntax for an insert operation is:
INSERT document INTO collection It can optionally end with an OPTIONS { … } clause.</description></item><item><title>`UPSERT` operation in AQL</title><link>http://localhost/3.10/aql/high-level-operations/upsert/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/high-level-operations/upsert/</guid><description>UPSERT looks up a single document that matches the provided example. If there is no match, an insert operation is executed to create a document. If a document is found, you can either update or replace the document. These subtypes are called upsert (update or insert) and repsert (replace or insert).
Each UPSERT operation is restricted to a single collection, and the collection name must not be dynamic. Only a single UPSERT statement per collection is allowed per AQL query, and it cannot be followed by read or write operations that access the same collection, by traversal operations, or AQL functions that can read documents.</description></item><item><title>`WITH` operation in AQL</title><link>http://localhost/3.10/aql/high-level-operations/with/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.10/aql/high-level-operations/with/</guid><description>Reading implicitly from a collections means that the collections are not specified explicitly in language constructs like the following:
FOR ... IN collection INSERT ... INTO collection UPDATE ... IN collection GRAPH &amp;quot;graph-name&amp;quot; (via the graph definition) Instead, the collections are only known at runtime of the query. Such dynamic collection access is invisible to the AQL query parser at query compile time. Dynamic access is possible via the DOCUMENT() function as well as with graph traversals (in particular the variant using collection sets), because edges may point to arbitrary vertex collections.</description></item></channel></rss>