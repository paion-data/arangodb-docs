<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Develop on ArangoDB Documentation</title><link>http://localhost/3.12/develop/</link><description>Recent content in Develop on ArangoDB Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://localhost/3.12/develop/index.xml" rel="self" type="application/rss+xml"/><item><title>Data Modeling and Operational Factors</title><link>http://localhost/3.12/develop/operational-factors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.12/develop/operational-factors/</guid><description>A well-designed data model allows you to write efficient AQL queries, increase throughput of CRUD operations, and makes sure your data is distributed in the most effective way.
Whether you design a new application with ArangoDB or port an existing one to use ArangoDB, you should always analyze the (expected) data access patterns of your application in conjunction with several factors:
Operation Atomicity All insert / update / replace / remove operations in ArangoDB are atomic on a single document, in the sense that any read operation either observes a single document write in its entirety or not at all, regardless of whether it is a read in the same transaction, a different transaction, or indeed another write operation implicitly reading the document (like update).</description></item><item><title>SatelliteCollections</title><link>http://localhost/3.12/develop/satellitecollections/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.12/develop/satellitecollections/</guid><description>ArangoDB Enterprise Edition ArangoGraph When doing joins in an ArangoDB cluster data has to be exchanged between different servers.
Joins are executed on a Coordinator. It prepares an execution plan and executes it. When executing, the Coordinator contacts all shards of the starting point of the join and ask for their data. The DB-Servers carrying out this operation loads all its local data and then ask the cluster for the other part of the join.</description></item><item><title>SmartJoins</title><link>http://localhost/3.12/develop/smartjoins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.12/develop/smartjoins/</guid><description>ArangoDB Enterprise Edition ArangoGraph Cluster joins without being smart When doing joins in an ArangoDB cluster, data has to be exchanged between different servers. Joins between different collections in a cluster normally require roundtrips between the shards of these collections for fetching the data. Requests are routed through an extra Coordinator hop.
For example, with two collections c1 and c2 with 4 shards each, the Coordinator initially contacts the 4 shards of c1.</description></item><item><title>Transactions</title><link>http://localhost/3.12/develop/transactions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.12/develop/transactions/</guid><description>Transaction Types ArangoDB offers different types of transactions:
AQL queries (with exceptions) Stream Transactions JavaScript Transactions Stream Transactions Stream Transactions allow you to perform multi-document transactions with individual begin and commit / abort commands. They work similar to the BEGIN, COMMIT, and ROLLBACK operations in relational database systems.
The client is responsible for making sure that transactions are committed or aborted when they are no longer needed, to avoid taking up resources.</description></item><item><title>Foxx Microservices</title><link>http://localhost/3.12/develop/foxx-microservices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.12/develop/foxx-microservices/</guid><description>Traditionally, server-side projects have been developed as standalone applications that guide the communication between the client-side frontend and the database backend. This has led to applications that were either developed as single monoliths or that duplicated data access and domain logic across all services that had to access the database. Additionally, tools to abstract away the underlying database calls could incur a lot of network overhead when using remote databases without careful optimization.</description></item><item><title>JavaScript API</title><link>http://localhost/3.12/develop/javascript-api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.12/develop/javascript-api/</guid><description>The JavaScript API is available on the server-side in the following contexts:
Foxx microservices User-defined AQL functions JavaScript Transactions Emergency console (arangod --console) Running on the server-side means that the code runs directly inside of the arangod process, bypassing the HTTP API. In cluster deployments, the code is executed on a Coordinator.
The JavaScript API is also available in the ArangoDB Shell client tool:
arangosh It communicates with the server via the HTTP API.</description></item><item><title>HTTP API Documentation</title><link>http://localhost/3.12/develop/http-api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.12/develop/http-api/</guid><description>ArangoDB servers expose an application programming interface (API) for managing the database system. It is based on the HTTP protocol that powers the world wide web. All interactions with a server are ultimately carried out via this HTTP API.
You can use the API by sending HTTP requests to the server directly, but the more common way of communicating with the server is via a database driver. A driver abstracts the complexity of the API away by providing a simple interface for your programming language or environment and handling things like authentication, connection pooling, asynchronous requests, and multi-part replies in the background.</description></item><item><title>Error codes and meanings</title><link>http://localhost/3.12/develop/error-codes-and-meanings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.12/develop/error-codes-and-meanings/</guid><description>Numbers, names, and descriptions of errors When an error occurs in an operation of an ArangoDB server, the HTTP REST API responds to a request with an HTTP status code like 400 Bad Request, 401 Unauthorized, 503 Service Unavailable, or similar. This code is typically also included in the body of the response, specifically the code attribute, along with the error attribute set to true.
HTTP/1.1 401 Unauthorized ... {&amp;#34;code&amp;#34;:401,&amp;#34;error&amp;#34;:true,&amp;#34;errorNum&amp;#34;:11,&amp;#34;errorMessage&amp;#34;:&amp;#34;not authorized to execute this request&amp;#34;} The error code only indicates the broad category of an error, based on the status codes defined by the HTTP protocol.</description></item><item><title>Official ArangoDB drivers</title><link>http://localhost/3.12/develop/drivers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.12/develop/drivers/</guid><description>Database drivers, also called connectors, adapters, or client libraries, let you access and manage database systems. ArangoDB drivers are interfaces between programming languages and ArangoDB, which enable software developers to connect to and manipulate ArangoDB deployments from within compiled programs or using scripting languages.
From a language perspective, documents and database structures can be integrated with data types and their methods. The precise mapping of concepts and methods depends on the capabilities and practices of each language.</description></item><item><title>Integrations</title><link>http://localhost/3.12/develop/integrations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.12/develop/integrations/</guid><description>Database integrations allow applications to work with different database systems using a common interface. They are higher-level than database drivers because they abstract away the details of specific database systems, especially the low-level network communication.
Spring Data The Spring Data integration for ArangoDB lets you use ArangoDB as a database system in Spring-based Java applications.
Tutorial Repository: github.com/arangodb/spring-data&amp;nbsp; Changelog&amp;nbsp; Spring Boot Starter The Spring Boot Starter simplifies the use of the Spring Data integration for ArangoDB so you get started quickly.</description></item></channel></rss>