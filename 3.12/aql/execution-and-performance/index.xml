<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AQL Execution and Performance on ArangoDB Documentation</title><link>http://localhost/3.12/aql/execution-and-performance/</link><description>Recent content in AQL Execution and Performance on ArangoDB Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://localhost/3.12/aql/execution-and-performance/index.xml" rel="self" type="application/rss+xml"/><item><title>AQL query statistics</title><link>http://localhost/3.12/aql/execution-and-performance/query-statistics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.12/aql/execution-and-performance/query-statistics/</guid><description>Execution statistics can be retrieved by calling getExtra() on the cursor. The statistics are returned in the return value&amp;rsquo;s stats attribute:
db._query(` FOR i IN 1..@count INSERT { _key: CONCAT(&amp;#39;anothertest&amp;#39;, TO_STRING(i)) } INTO mycollection`, { count: 100 }, {}, { fullCount: true } ).getExtra(); db._query({ &amp;#34;query&amp;#34;: ` FOR i IN 200..@count INSERT { _key: CONCAT(&amp;#39;anothertest&amp;#39;, TO_STRING(i)) } INTO mycollection`, &amp;#34;bindVars&amp;#34;: { count: 300 }, &amp;#34;options&amp;#34;: { fullCount: true } }).getExtra(); Show output [ArangoCollection 61584, &amp;#34;mycollection&amp;#34; (type document, status loaded)] { &amp;#34;warnings&amp;#34; : [ ], &amp;#34;stats&amp;#34; : { &amp;#34;writesExecuted&amp;#34; : 100, &amp;#34;writesIgnored&amp;#34; : 0, &amp;#34;documentLookups&amp;#34; : 0, &amp;#34;seeks&amp;#34; : 0, &amp;#34;scannedFull&amp;#34; : 0, &amp;#34;scannedIndex&amp;#34; : 0, &amp;#34;cursorsCreated&amp;#34; : 0, &amp;#34;cursorsRearmed&amp;#34; : 0, &amp;#34;cacheHits&amp;#34; : 0, &amp;#34;cacheMisses&amp;#34; : 0, &amp;#34;filtered&amp;#34; : 0, &amp;#34;httpRequests&amp;#34; : 0, &amp;#34;fullCount&amp;#34; : 0, &amp;#34;executionTime&amp;#34; : 0.</description></item><item><title>Parsing AQL queries</title><link>http://localhost/3.12/aql/execution-and-performance/parsing-queries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.12/aql/execution-and-performance/parsing-queries/</guid><description>ArangoDB provides an HTTP REST API for parsing and thus statically validating queries.
A query can also be parsed from the ArangoShell using ArangoStatement&amp;rsquo;s parse method. The parse method will throw an exception if the query is syntactically invalid. Otherwise, it will return the some information about the query.
The return value is an object with the collection names used in the query listed in the collections attribute, and all bind parameters listed in the bindVars attribute.</description></item><item><title>Explain AQL Queries</title><link>http://localhost/3.12/aql/execution-and-performance/explaining-queries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.12/aql/execution-and-performance/explaining-queries/</guid><description>If it is unclear how a given query will perform, clients can retrieve a query&amp;rsquo;s execution plan from the AQL query optimizer without actually executing the query. Getting the query execution plan from the optimizer is called explaining.
An explain throws an error if the given query is syntactically invalid. Otherwise, it returns the execution plan and some information about what optimizations could be applied to the query. The query is not executed.</description></item><item><title>Profiling and Hand-Optimizing AQL queries</title><link>http://localhost/3.12/aql/execution-and-performance/query-profiling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.12/aql/execution-and-performance/query-profiling/</guid><description>ArangoDB allows to execute your query with special instrumentation code enabled. It provides you a query plan with detailed execution statistics.
To use this in an interactive fashion on the shell you can use db._profileQuery(..) in arangosh. Alternatively, there is a button Profile in the Query tab of the web interface.
The printed execution plan then contains three additional columns:
Call: The number of times this query stage was executed Items: The number of temporary result rows (outputs) at this stage Filtered: The number of rows filtered away by this stage Runtime: The total time spent in this stage Below the execution plan there are additional sections for the overall runtime statistics and the query profile.</description></item><item><title>The AQL query optimizer</title><link>http://localhost/3.12/aql/execution-and-performance/query-optimization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.12/aql/execution-and-performance/query-optimization/</guid><description>AQL queries are parsed and planned. The optimizer might produce multiple execution plans for a single query. It then calculates the costs for all plans and picks the plan with the lowest total cost. This resulting plan is considered to be the optimal plan, which is then executed.
The optimizer is designed to only perform optimizations if they are safe, in the sense that an optimization should not modify the result of a query.</description></item><item><title>The execution plan cache for AQL queries</title><link>http://localhost/3.12/aql/execution-and-performance/caching-query-plans/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.12/aql/execution-and-performance/caching-query-plans/</guid><description>Query plan caching can reduce the total time for processing queries by avoiding to parse, plan, and optimize queries over and over again that effectively have the same execution plan with at most some changes to bind parameter values. It is especially useful for particular queries where a lot of time is spent on the query planning and optimization passes in proportion to the actual execution.
Use plan caching for queries Query plans are not cached by default.</description></item><item><title>The AQL query results cache</title><link>http://localhost/3.12/aql/execution-and-performance/caching-query-results/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.12/aql/execution-and-performance/caching-query-results/</guid><description>The purpose of the query results cache is to avoid repeated calculation of the same query results. It is useful if data-reading queries repeat a lot and there are not many write queries.
The query results cache is transparent so users do not need to manually invalidate results in it if underlying collection data are modified.
The AQL query results cache is only available for single servers, i.e. servers that are not part of a cluster setup.</description></item><item><title>AQL query logging</title><link>http://localhost/3.12/aql/execution-and-performance/query-logging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.12/aql/execution-and-performance/query-logging/</guid><description>Introduced in: v3.12.2
For debugging query issues and to understand usage patterns, it can be helpful to have a persistent log of queries.
ArangoDB lets you store information about past queries to a system collection with a configurable sampling probability and retention period. This allows you to analyze the metadata such as run time, memory usage, and failure reasons directly in the database system.
ArangoDB also supports event logging to a file, syslog, or the attached terminal.</description></item></channel></rss>