<!doctype html><html lang=en><head><link href=//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.no-icons.min.css rel=stylesheet><link href=//netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css rel=stylesheet><link href=/css/fontawesome-all.min.css rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/fontawesome-all.min.css rel=stylesheet></noscript><link href=/css/featherlight.min.css rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/featherlight.min.css rel=stylesheet></noscript><link href=/css/nucleus.css rel=stylesheet><link href=/css/fonts.css rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/fonts.css rel=stylesheet></noscript><link href=/css/theme.css rel=stylesheet><link href=/css/theme-relearn-light.css rel=stylesheet id=variant-style><link href=/css/print.css rel=stylesheet media=print><script src=/js/variant.js?1743774193></script>
<script>var root_url="/",baseUriFull,baseUri=root_url.replace(/\/$/,"");window.T_Copy_to_clipboard="",window.T_Copied_to_clipboard="",window.T_Copy_link_to_clipboard="",window.T_Link_copied_to_clipboard="",baseUriFull="http://localhost/",window.variants&&variants.init(["relearn-light"])</script><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.119.0"><meta itemprop=description property="description" content="Graphs let you represent things and the relationships between them using vertices and edges, to naturally model knowledge, social networks, cash flows, supply chains, and other information webs, and to extract valuable insights by analyzing this connected data"><meta property="og:url" content="http://localhost/3.13/graphs/"><meta property="og:title" content="Graphs"><meta property="og:type" content="website"><meta property="og:description" content="Graphs let you represent things and the relationships between them using vertices and edges, to naturally model knowledge, social networks, cash flows, supply chains, and other information webs, and to extract valuable insights by analyzing this connected data"><meta name=docsearch:version content="3.13"><title>Graphs | ArangoDB Documentation</title><link href=/images/favicon.png rel=icon type=image/png><script src=/js/jquery.min.js></script>
<script src=/js/clipboard.min.js?1743774193 defer></script>
<script src=/js/featherlight.min.js?1743774193 defer></script>
<script>var versions=[{alias:"devel",deprecated:!1,name:"3.13",version:"3.13.0"},{alias:"stable",deprecated:!1,name:"3.12",version:"3.12.4"},{alias:"3.11",deprecated:!1,name:"3.11",version:"3.11.13"},{alias:"3.10",deprecated:!0,name:"3.10",version:"3.10.14"}]</script><script>var develVersion={alias:"devel",deprecated:!1,name:"3.13",version:"3.13.0"}</script><script>var stableVersion={alias:"stable",deprecated:!1,name:"3.12",version:"3.12.4"}</script><script src=/js/codeblocks.js?1743774193 defer></script>
<script src=/js/theme.js?1743774193 defer></script></head><body><noscript>You need to enable JavaScript to use the ArangoDB documentation.</noscript><div id=page-wrapper class=page_content_splash style=height:auto;opacity:0><section id=page-main><section class=page-container id=page-container><header id=header style="transition:.5s padding ease-out,.15s" class="zn_header_white header-splash-new nav-down header-splash-wrap header1"><div class=header-block-left><div class=mobile-menu-toggle><button id=sidebar-toggle-navigation onclick=showSidebarHandler()><svg width="1.33em" height="1.33em" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button></div><div class=version-logo-container><div class="logo-container hasinfocard_img arangodb-logo-large"><div class=logo><a href=https://www.arangodb.com/><img src=/images/logo_main.png alt=ArangoDB title></a></div></div><div class=arangodb-logo-small><a href=https://arangodb.com/><img alt="ArangoDB Logo" src=/images/ArangoDB_Logo_White_small.png></a></div></div></div><div class=container-right style=display:hidden></div><div class=search-and-version-container><a href=# class="home-link is-current" aria-label="Go to home page" onclick=goToHomepage(event)></a><div id=searchbox></div><script type=text/javascript>const SCRIPT_SRC="https://unpkg.com/@inkeep/widgets-embed@0.2.290/dist/embed.js";function loadAndInitializeInkeep(){if(document.querySelector(`script[src="${SCRIPT_SRC}]"`))return;const e=document.createElement("script");e.type="module",e.src=SCRIPT_SRC,e.onload=initializeInkeep,document.head.appendChild(e)}function initializeInkeep(){const e=Inkeep({integrationId:"clo4lx6jk0000s601cp21x2ok",apiKey:"13b4e56966a76e86c6ff359cd795ee6a0412f751d75d6383",organizationId:"org_HGBkkzGAa4KeGJGh",organizationDisplayName:"ArangoDB",primaryBrandColor:"#80a54d",stringReplacementRules:[{matchingRule:{ruleType:"Substring",string:"Arangograph"},replaceWith:"ArangoGraph"},{matchingRule:{ruleType:"Substring",string:"Aql"},replaceWith:"AQL"},{matchingRule:{ruleType:"Substring",string:"Arangodb"},replaceWith:"ArangoDB"}],customCardSettings:[{filters:{UrlMatch:{ruleType:"PartialUrl",partialUrl:"arango.qubitpi.org"}},searchTabLabel:"Official Docs"},{filters:{UrlMatch:{ruleType:"PartialUrl",partialUrl:"developer.arangodb.com"}},searchTabLabel:"Developer Hub"},{filters:{UrlMatch:{ruleType:"PartialUrl",partialUrl:"arangodb.com"}},searchTabLabel:"Home"}]}),t=e.embed({componentType:"ChatButton",properties:{stylesheetUrls:["/css/fonts.css"],fixedPositionXOffset:"52px",baseSettings:{theme:{primaryColors:{textColorOnPrimary:"white"},tokens:{fonts:{body:"'Inter'",heading:"'Inter'"},zIndex:{overlay:1e4,modal:11e3,popover:12e3,skipLink:13e3,toast:14e3,tooltip:15e3}}}},aiChatSettings:{botAvatarSrcUrl:"/images/ArangoDB_Logo_White_small.png",quickQuestions:["What can you do with AQL that is not feasible with SQL?","How do I search for objects within arrays?","Where can I deploy my ArangoDB instance?"],getHelpCallToActions:[{icon:{builtIn:"FaSlack"},name:"Slack",url:"https://arangodb-community.slack.com/"}]},searchSettings:{tabSettings:{isAllTabEnabled:!1,alwaysDisplayedTabs:["Official Docs","Developer Hub","Home"]}}}})}loadAndInitializeInkeep()</script><div class=version-selector><select id=arangodb-version onchange=changeVersion()><option value=3.13>3.13</option><option value=3.12>3.12</option><option value=3.11>3.11</option><option value=3.10>3.10</option><option value=3.9>3.9</option><option value=3.8>3.8</option></select></div></div></header><iframe src=/nav.html title=description id=menu-iframe class="menu-iframe active" style=opacity:0></iframe><div class=container-main><div class=row-main><nav id=breadcrumbs><ol class=links itemscope itemtype=http://schema.org/BreadcrumbList><meta itemprop=itemListOrder content="Descending"><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><meta itemprop=position content="3.13"><a itemprop=item class=link href=/3.13/><span itemprop=name class=breadcrumb-entry>3.13.0</span></a>
<i class="fas fa-chevron-right fa-fw"></i></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><meta itemprop=position content="Graphs"><a itemprop=item class=link href=/3.13/graphs/><span itemprop=name class=breadcrumb-entry>Graphs</span></a></li></ol></nav><article class=default><div class="box notices cstyle warning"><div class=box-content-container><div class=box-content><i class="fas fa-exclamation-triangle"></i><div class=box-text><p>ArangoDB v3.13 is under development and not released yet.
This documentation is not final and potentially incomplete.</p></div></div></div></div><hgroup><h1>Graphs</h1><p class=lead>Graphs let you represent things and the relationships between them using vertices and edges, to naturally model knowledge, social networks, cash flows, supply chains, and other information webs, and to extract valuable insights by analyzing this connected data</p></hgroup><p>Graphs are information networks comprised of <strong>nodes</strong> and <strong>relations</strong>. Nodes
can represent objects, entities, abstract concepts, or ideas. Relations between
nodes can represent physical and social connections, temporal and causal
relationships, flows of information, energy, and material, interactions and
transactions, dependency and hierarchy, as well as similarity and relatedness of
any kind.</p><p><figure class=image-caption><img alt="Node - Relation - Node" src=/images/data-model-graph-relation-abstract.png><figcaption></figcaption></figure></p><p>For example, you can represent people by nodes and their friendships by
relations. This lets you form a graph that is a social network in this case.</p><p><figure class=image-caption><img alt="Mary - is friend of - John" src=/images/data-model-graph-relation-concrete.png><figcaption></figcaption></figure></p><p>The specific terms to refer to nodes and relations in a graph vary depending
on the field or context, but they are conceptually the same. In computer science
and mathematics, the terms <strong>vertices</strong> (singular: vertex) and <strong>edges</strong> are
commonly used to refer to nodes and relations, respectively. In information
science and data analysis, they are referred to as <em>entities</em> and <em>connection</em>.
In social sciences, they are often called <em>actors</em> and <em>ties</em> or <em>links</em>.
They may also be called <em>points</em> and <em>arcs</em>.</p><p>Using graphs with vertices to represent things and edges to define how they
relate to one another is a very expressive data model. It lets you represent
a wide variety of information in a compact and intuitive way. It lets you model
complex relationships and interactions of basically everything.</p><p><figure class=image-caption><img alt="Mary - bought - Book, is friend of - John" src=/images/data-model-graph-relations.png><figcaption></figcaption></figure></p><p>Graphs are commonly directed (<em>digraphs</em>), which means that each edge goes from
one vertex to another vertex in a specific direction. This lets you model
directional relationships, such as cause and effect or the flow of material,
energy, or information. In undirected graphs, edges don&rsquo;t have a direction and
the relationship between two vertices is considered to be the same in both
directions. For example, a friendship is a symmetrical relationships. If <em>Mary</em>
is a friend of <em>John</em>, then <em>John</em> is equally a friend of <em>Mary</em>. On the other
hand, <em>Mary</em> may subscribe to what <em>John</em> posts online, but this does not
automatically make <em>John</em> a subscriber of <em>Mary</em>&rsquo;s posts. It is an asymmetrical
relationship in graph terms. These two types of graphs have different properties
and different algorithms exist to analyze the data.</p><div class="box notices cstyle info"><div class=box-content-container><div class=box-content><i class="fas fa-info-circle"></i><div class=box-text>New to graphs? <a href=https://www.arangodb.com/arangodb-graph-course/ target=_blank rel="noopener noreferrer" class=link>Take our free graph course for freshers</a>&nbsp;<i class="fas fa-external-link-alt"></i>
and get from zero knowledge to advanced query techniques.</div></div></div></div><h2 id=graph-model>Graph model <a href=/3.13/graphs/#graph-model class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h2><p>Graph database systems like ArangoDB can store graphs and provide means to query
the connected data.</p><p>ArangoDB&rsquo;s graph model is that of a <strong>property graph</strong>. Every record, whether
vertex or edge, can have an arbitrary number of properties. Each document is a
fully-fledged JSON object and has a unique identifier.
This is different to the RDF graph model, where information is broken down into
triples of a subject, a predicate, and an object and where each triple is stored
separately, without an identifier for each statement.</p><p>Furthermore, ArangoDB&rsquo;s graph model can be classified as a <strong>labeled</strong> property
graph because you can group related edges using edge collections, with the
collection name being the label, but you can also use a property to assign one
or more types to an edge. You can also organize vertices in different
collections based on the types of entities.</p><p>Edges can only be stored in <strong>edge collections</strong>. Vertices are stored in
<strong>document collections</strong> which are also referred to as <strong>vertex collections</strong>
in the context of graphs. You can technically also use edges as vertices but
the usefulness is limited.</p><p>Edges in ArangoDB are always directed. Every edge document has special <code>_from</code>
and <code>_to</code> attributes to reference one other document in each of the two
attributes.</p><p>Vertices are referenced by their document identifiers. For example,
a friendship edge that connects <em>Mary</em> with <em>John</em> could look like
<code>{"_from": "Person/Mary", "_to": "Person/John", "_id": "isFriendOf/1234"}</code>.
Using this directed graph model means that relations you create with edges are
not reciprocal but you may create edges for the reverse direction (another edge
from <em>John</em> to <em>Mary</em>), or you can utilize ArangoDB&rsquo;s ability to follow edges
in the opposite direction (<strong>inbound</strong> instead of <strong>outbound</strong>) or ignore the
direction and follow them in both directions (<strong>any</strong>) as if it were an
undirected graph.</p><p>You can query graphs with ArangoDB&rsquo;s query language, see
<a href=/3.13/aql/graphs/ class=link>Graphs in AQL</a>.</p><h2 id=comparison-to-relational-database-systems>Comparison to relational database systems <a href=/3.13/graphs/#comparison-to-relational-database-systems class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h2><p>In relational database management systems (RDBMS), you have the construct of
a relation table to store <em>m:n</em> relations between two data tables.
An edge collection is somewhat similar to these relation tables.
Vertex collections resemble the data tables with the objects to connect.</p><p>While simple graph queries with a fixed number of hops via the relation table
may be doable in RDBMSes with SQL using several nested joins, graph databases
can handle an arbitrary and variable number of these hops over edge collections
which is called <strong>traversal</strong>.</p><p>Moreover, edges in one edge collection may point to vertices in different
vertex collections. It is common to have attributes attached to edges, like a
<em>label</em> naming the type of connection.</p><p>Edges have a direction, with their relations stored in the special <code>_from</code> and
<code>_to</code> attributes pointing <em>from</em> one document <em>to</em> another document.
In queries, you can define in which directions the edge relations may be followed
(<code>OUTBOUND</code>: <code>_from</code> → <code>_to</code>, <code>INBOUND</code>: <code>_from</code> ← <code>_to</code>, <code>ANY</code>: <code>_from</code> ↔ <code>_to</code>).</p><h2 id=supported-graph-algorithms>Supported graph algorithms <a href=/3.13/graphs/#supported-graph-algorithms class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h2><ul><li><a href=/3.13/aql/graphs/traversals/ class=link>Traversal</a><ul><li>following edges in outbound, inbound, or any direction</li><li>variable traversal depth between a defined minimum and maximum</li><li>breadth-first, depth-first, and weighted traversals</li><li>optionally with prune conditions</li></ul></li><li><a href=/3.13/aql/graphs/shortest-path/ class=link>Shortest Path</a></li><li><a href=/3.13/aql/graphs/all-shortest-paths/ class=link>All Shortest Paths</a></li><li><a href=/3.13/aql/graphs/k-shortest-paths/ class=link>k Shortest Paths</a></li><li><a href=/3.13/aql/graphs/k-paths/ class=link>k Paths</a></li></ul><h2 id=managed-and-unmanaged-graphs>Managed and unmanaged graphs <a href=/3.13/graphs/#managed-and-unmanaged-graphs class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h2><p>You can use vertex and edge collections directly, using them as an unmanaged
<strong>anonymous graph</strong>. In queries, you need to specify the involved collections
for graph operations like traversals.</p><p>You can also create a managed <strong>named graph</strong> to define a set of vertex and
edge collections along with the allowed relations. In queries, you only need to
specify the graph instead of the individual vertex and edge collections. There
are additional integrity checks when using the named graph interfaces.</p><p>Named graphs ensure graph integrity, both when inserting or removing edges or
vertices. You won&rsquo;t encounter dangling edges, even if you use the same vertex
collection in several named graphs. This involves more operations inside the
database system, which come at a cost. Therefore, anonymous graphs may be faster
in many operations. You can choose between no integrity guarantees, additional
effort to implement consistency checks in your application code, and server-side
integrity checks at a performance cost.</p><h3 id=named-graphs>Named Graphs <a href=/3.13/graphs/#named-graphs class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h3><p>Named graphs are completely managed by ArangoDB, ensuring data consistency if the
named graph interfaces and not the raw document manipulation interfaces are used.</p><p>The following types of named graphs exist:</p><ul><li><a href=/3.13/graphs/general-graphs/ class=link>General Graphs</a></li><li><a href=/3.13/graphs/smartgraphs/ class=link>SmartGraphs</a></li><li><a href=/3.13/graphs/enterprisegraphs/ class=link>EnterpriseGraphs</a></li><li><a href=/3.13/graphs/satellitegraphs/ class=link>SatelliteGraphs</a></li></ul><p>Selecting the optimal type of named graph in ArangoDB can help you achieve
the best performance and scalability for your data-intensive applications.</p><p>Which collections are used within a named graph is defined via
<strong>edge definitions</strong>. They describe which edge collections connect which
vertex collections. This is defined separately for the <em>from</em> and the <em>to</em>
per edge collection. A named graph can have one or more edge definitions.</p><p>The underlying collections of named graphs are still accessible using the
standard collection and document APIs. However, the graph modules add an
additional layer on top of these collections to provide integrity guarantees by
doing the following:</p><ul><li>Execute all modifications transactionally</li><li>Check that vertices references by edges in the <code>_from</code> and <code>_to</code> attributes
actually exist</li><li>Only allow to reference vertices from collections as specified by the
definition of the graph</li><li>Delete edges when a connected vertex is deleted to avoid dangling edges</li><li>Prohibit to use an edge collections in an edge definition with a different
set of <em>from</em> and <em>to</em> vertex collections than an existing edge definition
of any graph</li><li>Depending on the named graph type, there can be additional restrictions to
ensure a well-formed graph</li></ul><p>Your edge collections will only contain valid edges and you will never have
loose ends. These guarantees are lost if you access the collections in any other
way than the graph modules. For example, if you delete documents from your
vertex collections directly, the edges pointing to them remain in place.
Note that existing inconsistencies in your data are not corrected when you create
a named graph. Therefore, make sure you start with sound data as otherwise there
could be dangling edges after all. The graph modules guarantee to not introduce
new inconsistencies only.</p><p>You can create and manage named graphs in the following ways:</p><ul><li>With the <a href=/3.13/components/web-interface/graphs/ class=link>web interface</a>
in the <strong>Graphs</strong> section</li><li>In <em>arangosh</em> using the respective graph-related modules of the
JavaScript API (see the above links of the named graph types)</li><li>Using the <a href=/3.13/develop/http-api/graphs/named-graphs/ class=link>Gharial HTTP API</a></li></ul><h4 id=when-to-use-general-graphs>When to use General Graphs <a href=/3.13/graphs/#when-to-use-general-graphs class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h4><p>The General Graph is the basic graph type in ArangoDB, suitable for small-scale
graph use cases. Data in this type is randomly distributed across all configured
machines, making it easy to set up. However, this approach may result in
suboptimal query performance due to random data distribution.</p><div class="box notices cstyle tip"><div class=box-content-container><div class=box-content><i class="fas fa-check"></i><div class=box-text>General graphs are the easiest way to get started, no special configuration required.</div></div></div></div><p><figure class=image-caption><img alt="General Graph Random Distribution" src=/images/general-graph-distribution.png><figcaption></figcaption></figure></p><h4 id=when-to-use-smartgraphs>When to use SmartGraphs <a href=/3.13/graphs/#when-to-use-smartgraphs class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h4><p>The SmartGraphs further optimize data distribution by allowing you to define a
property called <code>smartGraphAttribute</code>. This property leverages your application&rsquo;s
knowledge about the graph&rsquo;s interconnected communities to improve data
organization and query performance.</p><div class="box notices cstyle tip"><div class=box-content-container><div class=box-content><i class="fas fa-check"></i><div class=box-text>For the best query performance, especially in highly interconnected graph
scenarios, use SmartGraphs. Organize your data efficiently using the
<code>smartGraphAttribute</code>.</div></div></div></div><p><figure class=image-caption><img alt="SmartGraph Distribution" src=/images/smartgraph-distribution.png><figcaption></figcaption></figure></p><h4 id=when-to-use-enterprisegraphs>When to use EnterpriseGraphs <a href=/3.13/graphs/#when-to-use-enterprisegraphs class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h4><p>The EnterpriseGraphs are designed for large-scale graph use cases in enterprise
environments. While data is also randomly sharded, this graph type ensures that
all edges adjacent to a vertex are co-located on the same server. This
optimization significantly improves query performance by reducing network hops.</p><div class="box notices cstyle tip"><div class=box-content-container><div class=box-content><i class="fas fa-check"></i><div class=box-text>If you need improved query execution without manual data distribution, consider
using EnterpriseGraphs.</div></div></div></div><p><figure class=image-caption><img alt="EnterpriseGraph Distribution" src=/images/enterprisegraph-distribution.png><figcaption></figcaption></figure></p><h4 id=when-to-use-satellitegraphs>When to use SatelliteGraphs <a href=/3.13/graphs/#when-to-use-satellitegraphs class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h4><p>SatelliteGraphs replicate one or more graphs to all machines within a cluster
so queries can be executed locally. All vertices and edges are available on
every node for maximum data locality, therefore no network hops are required
to traverse the graph.</p><div class="box notices cstyle tip"><div class=box-content-container><div class=box-content><i class="fas fa-check"></i><div class=box-text>When using SatelliteGraphs, expect slower write performance because the data is
replicated across DB-Servers. For a more efficient option that doesn&rsquo;t replicate
all graph data to every server in your cluster, consider SmartGraphs.</div></div></div></div><h3 id=anonymous-graphs>Anonymous graphs <a href=/3.13/graphs/#anonymous-graphs class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h3><p>An anonymous graph is the graph that your data implicitly defines by edges that
reference vertices and that you directly use by defining the vertex and edge
collections for graph operations such as traversals and path finding algorithms
in queries. You can also work with <a href=/3.13/graphs/working-with-edges/ class=link>edges</a> directly.</p><p>Anonymous graphs don&rsquo;t have edge definitions describing which vertex collection
is connected by which edge collection. The graph model has to be maintained by
the client-side code. This gives you more freedom than the strict named graphs
such as the ability to let an edge reference documents from any collections in
the current database.</p><h2 id=model-data-with-graphs>Model data with graphs <a href=/3.13/graphs/#model-data-with-graphs class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h2><p>Graphs can have different structures, called <strong>topologies</strong>. The topology
describes how the vertices and edges are arranged by classifying the pattern of
connections. Some relevant classes are:</p><ul><li>Cyclic: a graph that contains at least one path that starts and ends at the
same node. An edge can also originate from and point to the same vertex.</li><li>Acyclic: a graph that contains no cycles</li><li>Tree: a directed acyclic graph (DAG) without cycles and exactly one path
between any two vertices in the graph</li><li>Dense: a graph with edges between most pairs of vertices</li><li>Sparse: a graph where only few pairs of vertices are connected by edges</li></ul><p>The topology for your graphs will vary depending on your data and requirements
but you always have a degree of freedom when modeling the data.</p><h3 id=what-information-should-be-stored-in-edges-and-what-in-vertices>What information should be stored in edges and what in vertices <a href=/3.13/graphs/#what-information-should-be-stored-in-edges-and-what-in-vertices class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h3><p>The main objects in your data model, such as users, groups, or articles, are
usually considered to be vertices. For each type of object, a document collection
should store the individual entities. Entities can be connected by edges to
express and classify relations between vertices. It often makes sense to have
an edge collection per relation type.</p><p>ArangoDB does not require you to store your data in graph structures with edges
and vertices. You can also decide to embed attributes such as which groups a
user is part of or store <code>_id</code>s of documents in another document instead of
connecting the documents with edges. It can be a meaningful performance
optimization for <em>1:n</em> relationships if your data is not focused on relations
and you don&rsquo;t need graph traversal with varying depth. It usually means
to introduce some redundancy and possibly inconsistencies if you embed data, but
it can be an acceptable tradeoff.</p><p><strong>Vertices</strong>:
Assume you have two vertex collections, <code>Users</code> and <code>Groups</code>. Documents in the
<code>Groups</code> collection contain the attributes of the group, i.e. when it was founded,
its subject, and so on. Documents in the <code>Users</code> collection contain the data
specific to a user, like name, birthday, hobbies, et cetera.</p><p><strong>Edges</strong>:
You can use an edge collection to store relations between users and groups.
Since multiple users may be in an arbitrary number of groups, this is an <strong>m:n</strong>
relation. The edge collection can be called <code>UsersInGroups</code> to store edges like
with <code>_from</code> pointing to <code>Users/John</code> and <code>_to</code> pointing to
<code>Groups/BowlingGroupHappyPin</code>. This makes the user <strong>John</strong> a member of the group
<strong>Bowling Group Happy Pin</strong>. You can store additional properties in document
attributes to qualify the relation further, like the permissions of <strong>John</strong> in
this group, the date when John joined the group, and so on.</p><p><figure class=image-caption><img alt="User in group example" src=/images/graph_user_in_group.png><figcaption></figcaption></figure></p><p>As a rule of thumb, if you use documents and their attributes in a sentence,
nouns would typically be vertices, and the verbs the edges.
You can see this in the <a href=/3.13/graphs/example-graphs/#knows-graph class=link>Knows Graph</a>:</p><pre><code>Alice knows Bob, who in term knows Charlie.
</code></pre><p>The advantages of using graphs is that you are not limited to a fixed number of
<strong>m:n</strong> relations for a document, but you can have an arbitrary number of
relations. Edges can be traversed in both directions, so it is easy to determine
all groups a user is in, but also to find out which members a certain group has.
You can also interconnect users to create a social network.</p><p>Using the graph data model, dealing with data that has lots of relations stays
manageable and can be queried in very flexible ways, whereas it would hard to
handle it in a relational database system.</p><h3 id=multiple-edge-collections-vs-filters-on-edge-document-attributes>Multiple edge collections vs. <code>FILTER</code>s on edge document attributes <a href=/3.13/graphs/#multiple-edge-collections-vs-filters-on-edge-document-attributes class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h3><p>If you want to only traverse edges of a specific type, there are two ways to
achieve this.</p><p>The first is to use an attribute in the edge document, e.g. <code>type</code>, where you
specify a differentiator for the edge, like <code>"friends"</code>, <code>"family"</code>, <code>"married"</code>,
or <code>"workmates"</code>, so that you can later use <code>FILTER e.type = "friends"</code> in
queries if you only want to follow the friend edges.</p><p>Another way, which may be more efficient in some cases, is to use different
edge collections for different types of edges. You could have <code>friend_edges</code>,
<code>family_edges</code>, <code>married_edges</code>, and <code>workmate_edges</code> as edge collections.
You can then limit the query to a subset of the edge and vertex collections.
To only follow friend edges, you would specify <code>friend_edges</code> as sole edge collection.</p><p>Both approaches have advantages and disadvantages. <code>FILTER</code> operations on edge
attributes are more costly at query time because a condition needs to be checked
for every traversed edge, which may become a bottleneck. If the set of edges is
restricted by only using a certain edge collection, then other types of edges
are not traversed in the first place and there is no need to check for a <code>type</code>
attribute with <code>FILTER</code>. On the other hand, using a <code>type</code> attribute allows you
to update edges more easily and you can even assign multiple types to a single
edge.</p><p>The multiple edge collections approach is limited by the number of collections
that can be used in one query, see <a href=/3.13/aql/fundamentals/limitations/ class=link>Known limitations for AQL queries</a>.
Every collection used in a query requires some resources inside of ArangoDB and
the number is therefore limited to cap the resource requirements. You may also
have constraints on other edge attributes, such as a persistent index with a
unique constraint, which requires the documents to be in a single collection for
the uniqueness guarantee, and it may thus not be possible to store the different
types of edges in multiple edge collections.</p><p>In conclusion, if your edges have about a dozen different types, you can choose
the approach with multiple edge collections. Otherwise, the <code>FILTER</code> approach is
preferred. You can still use <code>FILTER</code> operations on edges as needed if you choose
the former approach. It merely removes the need of a <code>FILTER</code> on the <code>type</code>,
everything else can stay the same.</p><h3 id=example-graphs>Example graphs <a href=/3.13/graphs/#example-graphs class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h3><p>For example data that you can use for learning graphs, see
<a href=/3.13/graphs/example-graphs/ class=link>Example graphs</a>.</p><h2 id=back-up-and-restore-graph>Back up and restore graph <a href=/3.13/graphs/#back-up-and-restore-graph class=header-link onclick=copyURI(event)><span></span><i class="fa fa-link"></i></a></h2><p>For backups of your graph data, you can use <a href=/3.13/components/tools/arangodump/ class=link><em>arangodump</em></a>
to create the backup, and <a href=/3.13/components/tools/arangorestore/ class=link><em>arangorestore</em></a> to
restore a backup. However, note the following:</p><ul><li>You need to include the <code>_graphs</code> system collection if you want to back up
named graphs as the graph definitions are stored in this collection.</li><li>You need to back up all vertex and edge collections your graph consists of.
A partial dump/restore may not work.</li></ul><nav class=pagination><span class=prev><a class="nav nav-prev link" href=/3.13/aql/><i class="fas fa-chevron-left fa-fw"></i><p>AQL</p></a></span><span class=next><a class="nav nav-next link" href=/3.13/graphs/general-graphs/><p>General Graphs</p><i class="fas fa-chevron-right fa-fw"></i></a></span></nav></article><div class=toc-container><a class=edit-page aria-label href=https://github.com/arangodb/docs-hugo/edit/main/site/content/3.13/graphs/_index.md target=_blank><i class="fab fa-fw fa-github edit-page-icon"></i></a><div class=toc><div class=toc-content><div class=toc-header><p>On this page</p></div><nav id=TableOfContents><div class=level-2><a href=#graph-model>Graph model</a></div><div class=level-2><a href=#comparison-to-relational-database-systems>Comparison to relational database systems</a></div><div class=level-2><a href=#supported-graph-algorithms>Supported graph algorithms</a></div><div class=level-2><a href=#managed-and-unmanaged-graphs>Managed and unmanaged graphs</a></div><div class=level-3><a href=#named-graphs>Named Graphs</a></div><div class=level-4><a href=#when-to-use-general-graphs>When to use General Graphs</a></div><div class=level-4><a href=#when-to-use-smartgraphs>When to use SmartGraphs</a></div><div class=level-4><a href=#when-to-use-enterprisegraphs>When to use EnterpriseGraphs</a></div><div class=level-4><a href=#when-to-use-satellitegraphs>When to use SatelliteGraphs</a></div><div class=level-3><a href=#anonymous-graphs>Anonymous graphs</a></div><div class=level-2><a href=#model-data-with-graphs>Model data with graphs</a></div><div class=level-3><a href=#what-information-should-be-stored-in-edges-and-what-in-vertices>What information should be stored in edges and what in vertices</a></div><div class=level-3><a href=#multiple-edge-collections-vs-filters-on-edge-document-attributes>Multiple edge collections vs. <code>FILTER</code>s on edge document attributes</a></div><div class=level-3><a href=#example-graphs>Example graphs</a></div><div class=level-2><a href=#back-up-and-restore-graph>Back up and restore graph</a></div></nav></div></div></div></div></div></section></section></div><button class="back-to-top hidden" onclick=goToTop(event) href=#><i class="fa fa-arrow-up"></i></button><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@docsearch/css@3>
<script src=https://cdn.jsdelivr.net/npm/@docsearch/js@3></script>
<script type=text/javascript>window.setupDocSearch=function(e){if(!window.docsearch)return;docsearch({appId:"OK3ZBQ5982",apiKey:"500c85ccecb335d507fe4449aed12e1d",indexName:"arangodbdocs",insights:!0,container:"#searchbox",debug:!1,maxResultsPerGroup:10,searchParameters:{facetFilters:[`version:${e}`]}})}</script></body></html>