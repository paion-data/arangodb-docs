<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AQL Query Patterns and Examples on ArangoDB Documentation</title><link>http://localhost/3.13/aql/examples-and-query-patterns/</link><description>Recent content in AQL Query Patterns and Examples on ArangoDB Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://localhost/3.13/aql/examples-and-query-patterns/index.xml" rel="self" type="application/rss+xml"/><item><title>Create Test Data with AQL</title><link>http://localhost/3.13/aql/examples-and-query-patterns/create-test-data/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.13/aql/examples-and-query-patterns/create-test-data/</guid><description>We assume that there is already a collection to the hold documents called myCollection in below example queries.
One of the easiest ways to fill a collection with test data is to use an AQL query that iterates over a range.
Run the following AQL query e.g. from the AQL Editor in the web interface to insert 1,000 documents into the collection:
FOR i IN 1..1000 INSERT { name: CONCAT(&amp;#34;test&amp;#34;, i) } IN myCollection The number of documents to create can be modified easily be adjusting the range boundary values.</description></item><item><title>Counting in AQL</title><link>http://localhost/3.13/aql/examples-and-query-patterns/counting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.13/aql/examples-and-query-patterns/counting/</guid><description>Amount of documents in a collection To return the count of documents that currently exist in a collection, you can call the LENGTH() function:
RETURN LENGTH(collection) This type of call is optimized since 2.8 (no unnecessary intermediate result is built up in memory) and it is therefore the preferred way to determine the count. Internally, COLLECTION_COUNT() is called.
In earlier versions with COLLECT ... WITH COUNT INTO available (since 2.</description></item><item><title>Dynamic Attribute Names in AQL</title><link>http://localhost/3.13/aql/examples-and-query-patterns/dynamic-attribute-names/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.13/aql/examples-and-query-patterns/dynamic-attribute-names/</guid><description>You might want an AQL query to return results with attribute names assembled by a function, or with a variable number of attributes.
This will not work by specifying the result using a regular object literal, as object literals require the names and numbers of attributes to be fixed at query compile time.
There are two solutions to getting dynamic attribute names to work:
Using expressions as attribute names (fixed amount of attributes) Using subqueries and the ZIP() function (variable amount of attributes) Using expressions as attribute names This solution works in cases where the number of dynamic attributes to return is known in advance, and only the attribute names need to be calculated using an expression.</description></item><item><title>Projections and Filters in AQL</title><link>http://localhost/3.13/aql/examples-and-query-patterns/projections-and-filters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.13/aql/examples-and-query-patterns/projections-and-filters/</guid><description>Returning unaltered documents To return three complete documents from collection users, the following query can be used:
FOR u IN users LIMIT 0, 3 RETURN u [ { &amp;#34;_id&amp;#34; : &amp;#34;users/229886047207520&amp;#34;, &amp;#34;_rev&amp;#34; : &amp;#34;229886047207520&amp;#34;, &amp;#34;_key&amp;#34; : &amp;#34;229886047207520&amp;#34;, &amp;#34;active&amp;#34; : true, &amp;#34;id&amp;#34; : 206, &amp;#34;age&amp;#34; : 31, &amp;#34;gender&amp;#34; : &amp;#34;f&amp;#34;, &amp;#34;name&amp;#34; : &amp;#34;Abigail&amp;#34; }, { &amp;#34;_id&amp;#34; : &amp;#34;users/229886045175904&amp;#34;, &amp;#34;_rev&amp;#34; : &amp;#34;229886045175904&amp;#34;, &amp;#34;_key&amp;#34; : &amp;#34;229886045175904&amp;#34;, &amp;#34;active&amp;#34; : true, &amp;#34;id&amp;#34; : 101, &amp;#34;age&amp;#34; : 36, &amp;#34;name&amp;#34; : &amp;#34;Fred&amp;#34;, &amp;#34;gender&amp;#34; : &amp;#34;m&amp;#34; }, { &amp;#34;_id&amp;#34; : &amp;#34;users/229886047469664&amp;#34;, &amp;#34;_rev&amp;#34; : &amp;#34;229886047469664&amp;#34;, &amp;#34;_key&amp;#34; : &amp;#34;229886047469664&amp;#34;, &amp;#34;active&amp;#34; : true, &amp;#34;id&amp;#34; : 208, &amp;#34;age&amp;#34; : 29, &amp;#34;name&amp;#34; : &amp;#34;Mary&amp;#34;, &amp;#34;gender&amp;#34; : &amp;#34;f&amp;#34; } ] Note that there is a LIMIT clause but no SORT clause.</description></item><item><title>Using Joins in AQL</title><link>http://localhost/3.13/aql/examples-and-query-patterns/joins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.13/aql/examples-and-query-patterns/joins/</guid><description>The two common scenarios when you want to join documents of collections are:
One-to-Many: You may have a users collection and a cities collection. A user lives in a city and you need the city information during a query about the user.
Many-To-Many: You may have a authors collection and a books collection. An author can write many books and a book can have many authors. You want to return a list of books with their authors.</description></item><item><title>Grouping and aggregating data in AQL</title><link>http://localhost/3.13/aql/examples-and-query-patterns/grouping/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.13/aql/examples-and-query-patterns/grouping/</guid><description>To group results by arbitrary criteria, AQL provides the COLLECT keyword. COLLECT will perform a grouping, but no aggregation. Aggregation can still be added in the query if required.
Ensuring uniqueness COLLECT can be used to make a result set unique. The following query will return each distinct age attribute value only once:
FOR u IN users COLLECT age = u.age RETURN age This is grouping without tracking the group values, but just the group criterion (age) value.</description></item><item><title>AQL Example Queries on an Actors and Movies Dataset</title><link>http://localhost/3.13/aql/examples-and-query-patterns/actors-and-movies-dataset-queries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.13/aql/examples-and-query-patterns/actors-and-movies-dataset-queries/</guid><description>Given a graph [actors] – actsIn → [movies] with two vertex collections actors and movies and an edge collection actsIn with edges pointing from actor to movie, plenty of interesting queries are possible:
All actors who acted in &amp;ldquo;movie1&amp;rdquo; OR &amp;ldquo;movie2&amp;rdquo; All actors who acted in both &amp;ldquo;movie1&amp;rdquo; AND &amp;ldquo;movie2&amp;rdquo; All common movies between &amp;ldquo;actor1&amp;rdquo; and &amp;ldquo;actor2&amp;rdquo; All actors who acted in 3 or more movies All movies where exactly 6 actors acted in The number of actors by movie The number of movies by actor The number of movies acted in between two years by actor The years and number of movies by actor with actor name Dataset We will be using arangosh to create and query the data.</description></item><item><title>Combining AQL Graph Traversals</title><link>http://localhost/3.13/aql/examples-and-query-patterns/traversals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.13/aql/examples-and-query-patterns/traversals/</guid><description>Finding the start vertex via a geo query Our first example will locate the start vertex for a graph traversal via a geo index. We use the City Graph and its geo indexes:
var examples = require(&amp;#34;@arangodb/graph-examples/example-graph&amp;#34;); examples.loadGraph(&amp;#34;routeplanner&amp;#34;); Show output {[GeneralGraph] &amp;#34;frenchHighway&amp;#34; : [ArangoCollection 344, &amp;#34;frenchHighway&amp;#34; (type edge, status loaded)], &amp;#34;frenchCity&amp;#34; : [ArangoCollection 341, &amp;#34;frenchCity&amp;#34; (type document, status loaded)], &amp;#34;germanHighway&amp;#34; : [ArangoCollection 343, &amp;#34;germanHighway&amp;#34; (type edge, status loaded)], &amp;#34;germanCity&amp;#34; : [ArangoCollection 340, &amp;#34;germanCity&amp;#34; (type document, status loaded)], &amp;#34;internationalHighway&amp;#34; : [ArangoCollection 342, &amp;#34;internationalHighway&amp;#34; (type edge, status loaded)] } We search all german cities in a range of 400 km around the ex-capital Bonn: Hamburg and Cologne.</description></item><item><title>Remove vertices with AQL</title><link>http://localhost/3.13/aql/examples-and-query-patterns/remove-vertex/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.13/aql/examples-and-query-patterns/remove-vertex/</guid><description>Deleting vertices with associated edges is currently not handled via AQL while the graph management interface and the REST API for the graph module offer a vertex deletion functionality. However, as shown in this example based on the Knows Graph, a query for this use case can be created.
When deleting vertex eve from the graph, we also want the edges eve -&amp;gt; alice and eve -&amp;gt; bob to be removed.</description></item><item><title>AQL queries without collections</title><link>http://localhost/3.13/aql/examples-and-query-patterns/queries-without-collections/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.13/aql/examples-and-query-patterns/queries-without-collections/</guid><description>AQL queries typically access one or more collections to read from documents or to modify them. Queries don&amp;rsquo;t necessarily have to involve collections however. Below are a few examples of that.
Following is a query that returns a string value. The result string is contained in an array because the result of every valid query is an array:
RETURN &amp;#34;this will be returned&amp;#34; Show output [ &amp;#34;this will be returned&amp;#34; ] You may use variables, call functions and return arbitrarily structured results:</description></item><item><title>Diffing Two Documents in AQL</title><link>http://localhost/3.13/aql/examples-and-query-patterns/diffing-two-documents/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.13/aql/examples-and-query-patterns/diffing-two-documents/</guid><description>There is no built-in AQL function to compare the attributes of two documents, but it is easily possible to build a query that does:
// input document 1 LET doc1 = { &amp;#34;foo&amp;#34;: &amp;#34;bar&amp;#34;, &amp;#34;a&amp;#34;: 1, &amp;#34;b&amp;#34;: 2 } // input document 2 LET doc2 = { &amp;#34;foo&amp;#34;: &amp;#34;baz&amp;#34;, &amp;#34;a&amp;#34;: 2, &amp;#34;c&amp;#34;: 3 } // collect attributes present in doc1, but missing in doc2 LET missing = ( FOR key IN ATTRIBUTES(doc1) FILTER !</description></item><item><title>Conditionally Inserting and Modifying Documents</title><link>http://localhost/3.13/aql/examples-and-query-patterns/upsert-repsert-guide/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/3.13/aql/examples-and-query-patterns/upsert-repsert-guide/</guid><description>A common requirement when ingesting data is to ensure that certain documents exist in a collection. Oftentimes when running a command it is unclear whether the target documents are already present in the collection or need to be inserted first.
Unconditional INSERT operations will not work here, because they may run into errors if the target documents already exist. This will trigger a &amp;ldquo;unique constraint violation&amp;rdquo; error. Unconditional UPDATE or REPLACE operations will also fail, because they require that the target documents are already present.</description></item></channel></rss>